<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TINXUE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-14T05:35:11.721Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>听雪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://yoursite.com/2019/01/17/面试必备之乐观锁与悲观锁/</id>
    <published>2019-01-17T14:37:08.469Z</published>
    <updated>2019-01-14T05:35:11.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何谓悲观锁与乐观锁"><a href="#何谓悲观锁与乐观锁" class="headerlink" title="何谓悲观锁与乐观锁"></a>何谓悲观锁与乐观锁</h3><blockquote><p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p></blockquote><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p><h4 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h4><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h3 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h3><blockquote><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p></blockquote><h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子：</strong><br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><ul><li>需要读写的内存值 V </li><li>进行比较的值 A </li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p><p>关于自旋锁，大家可以看一下这篇文章，非常不错：<a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">《<br>面试必备之深入理解自旋锁》</a></p><h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote><p> ABA 问题是乐观锁一个常见的问题</p></blockquote><h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p><p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p><h3 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h3><blockquote><p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p></blockquote><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ol><p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;何谓悲观锁与乐观锁&quot;&gt;&lt;a href=&quot;#何谓悲观锁与乐观锁&quot; class=&quot;headerlink&quot; title=&quot;何谓悲观锁与乐观锁&quot;&gt;&lt;/a&gt;何谓悲观锁与乐观锁&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E7%BE%8E%E5%9B%A2-%E7%BB%88%E7%BB%93%E7%AF%87/"/>
    <id>http://yoursite.com/2019/01/17/美团-终结篇/</id>
    <published>2019-01-17T14:37:08.469Z</published>
    <updated>2019-01-14T05:35:11.718Z</updated>
    
    <content type="html"><![CDATA[<!-- MarkdownTOC --><ul><li><a href="#一-object类有哪些方法">一. Object类有哪些方法?</a><ul><li><a href="#11-object类的常见方法总结">1.1 Object类的常见方法总结</a></li><li><a href="#12-hashcode与equals">1.2 hashCode与equals</a><ul><li><a href="#121-hashcode（）介绍">1.2.1 hashCode（）介绍</a></li><li><a href="#122-为什么要有hashcode">1.2.2 为什么要有hashCode</a></li><li><a href="#123-hashcode（）与equals（）的相关规定">1.2.3 hashCode（）与equals（）的相关规定</a></li><li><a href="#124-为什么两个对象有相同的hashcode值，它们也不一定是相等的？">1.2.4 为什么两个对象有相同的hashcode值，它们也不一定是相等的？</a></li></ul></li><li><a href="#13-与equals">1.3  ==与equals</a></li></ul></li><li><a href="#二-concurrenthashmap-相关问题">二 ConcurrentHashMap 相关问题</a><ul><li><a href="#21-concurrenthashmap-和-hashtable-的区别">2.1  ConcurrentHashMap 和 Hashtable 的区别</a></li><li><a href="#22-concurrenthashmap线程安全的具体实现方式底层具体实现">2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现</a><ul><li><a href="#jdk17（上面有示意图）">JDK1.7（上面有示意图）</a></li><li><a href="#jdk18-（上面有示意图）">JDK1.8 （上面有示意图）</a></li></ul></li></ul></li><li><a href="#三-谈谈-synchronized-和-reentrantlock-的区别">三 谈谈 synchronized 和 ReenTrantLock 的区别</a></li><li><a href="#四-线程池了解吗？">四 线程池了解吗？</a><ul><li><a href="#41-为什么要用线程池？">4.1 为什么要用线程池？</a></li><li><a href="#42-java-提供了哪几种线程池？他们各自的使用场景是什么？">4.2 Java 提供了哪几种线程池？他们各自的使用场景是什么？</a><ul><li><a href="#java-主要提供了下面4种线程池">Java 主要提供了下面4种线程池</a></li><li><a href="#各种线程池的适用场景介绍">各种线程池的适用场景介绍</a></li></ul></li><li><a href="#43-创建的线程池的方式">4.3 创建的线程池的方式</a></li></ul></li><li><a href="#五-nginx">五 Nginx</a><ul><li><a href="#51-简单介绍一下nginx">5.1 简单介绍一下Nginx</a><ul><li><a href="#反向代理">反向代理</a></li><li><a href="#负载均衡">负载均衡</a></li><li><a href="#动静分离">动静分离</a></li></ul></li><li><a href="#52-为什么要用-nginx-？">5.2 为什么要用 Nginx ？</a></li><li><a href="#53-nginx-的四个主要组成部分了解吗？">5.3  Nginx 的四个主要组成部分了解吗？</a></li></ul></li></ul><!-- /MarkdownTOC --><blockquote><p>下面这个问题，面试中经常出现。我觉得不论是出于应付面试还是说更好地掌握Java这门编程语言，大家都要掌握！</p></blockquote><h1 id="一-Object类有哪些方法"><a href="#一-Object类有哪些方法" class="headerlink" title="一. Object类有哪些方法?"></a>一. Object类有哪些方法?</h1><h3 id="1-1-Object类的常见方法总结"><a href="#1-1-Object类的常见方法总结" class="headerlink" title="1.1 Object类的常见方法总结"></a>1.1 Object类的常见方法总结</h3><p>Object类是一个特殊的类，是所有类的父类。它主要提供了以下11个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><blockquote><p>问完上面这个问题之后，面试官很可能紧接着就会问你“hashCode与equals”相关的问题。</p></blockquote><h3 id="1-2-hashCode与equals"><a href="#1-2-hashCode与equals" class="headerlink" title="1.2 hashCode与equals"></a>1.2 hashCode与equals</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><h4 id="1-2-1-hashCode（）介绍"><a href="#1-2-1-hashCode（）介绍" class="headerlink" title="1.2.1 hashCode（）介绍"></a>1.2.1 hashCode（）介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="1-2-2-为什么要有hashCode"><a href="#1-2-2-为什么要有hashCode" class="headerlink" title="1.2.2 为什么要有hashCode"></a>1.2.2 为什么要有hashCode</h4><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p><h4 id="1-2-3-hashCode（）与equals（）的相关规定"><a href="#1-2-3-hashCode（）与equals（）的相关规定" class="headerlink" title="1.2.3 hashCode（）与equals（）的相关规定"></a>1.2.3 hashCode（）与equals（）的相关规定</h4><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h4 id="1-2-4-为什么两个对象有相同的hashcode值，它们也不一定是相等的？"><a href="#1-2-4-为什么两个对象有相同的hashcode值，它们也不一定是相等的？" class="headerlink" title="1.2.4 为什么两个对象有相同的hashcode值，它们也不一定是相等的？"></a>1.2.4 为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h4><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p><p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p><blockquote><p> ==与equals 的对比也是比较常问的基础问题之一！</p></blockquote><h3 id="1-3-与equals"><a href="#1-3-与equals" class="headerlink" title="1.3  ==与equals"></a>1.3  ==与equals</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul><blockquote><p>在<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484625&amp;idx=1&amp;sn=9c4fa1f7d4291a5fbd7daa44bac2b012&amp;chksm=fd9852b0caefdba6edcf9a827aa4a17ddc97bf6ad2e5ee6f7e1aa1b443b54444d05d2b76732b&amp;token=723699735&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列5】美团面经总结进阶篇 （附详解答案）</a> 这篇文章中，我们已经提到了一下关于 HashMap 在面试中常见的问题：HashMap 的底层实现、简单讲一下自己对于红黑树的理解、红黑树这么优秀，为何不直接使用红黑树得了、HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别。HashMap 和 ConcurrentHashMap 这俩兄弟在一般只要面试中问到集合相关的问题就一定会被问到，所以各位务必引起重视！</p></blockquote><h1 id="二-ConcurrentHashMap-相关问题"><a href="#二-ConcurrentHashMap-相关问题" class="headerlink" title="二 ConcurrentHashMap 相关问题"></a>二 ConcurrentHashMap 相关问题</h1><h3 id="2-1-ConcurrentHashMap-和-Hashtable-的区别"><a href="#2-1-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="2.1  ConcurrentHashMap 和 Hashtable 的区别"></a>2.1  ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong>  整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong> </p><p>图片来源：<a href="http://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html</a></p><p>HashTable:<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/50656681.jpg" alt=""></p><p>JDK1.7的ConcurrentHashMap：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/33120488.jpg" alt=""><br>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点<br>Node: 链表节点）：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/97739220.jpg" alt=""></p><h3 id="2-2-ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#2-2-ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7（上面有示意图）"><a href="#JDK1-7（上面有示意图）" class="headerlink" title="JDK1.7（上面有示意图）"></a>JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p><p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry  数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><h4 id="JDK1-8-（上面有示意图）"><a href="#JDK1-8-（上面有示意图）" class="headerlink" title="JDK1.8 （上面有示意图）"></a>JDK1.8 （上面有示意图）</h4><p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。</p><p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><h1 id="三-谈谈-synchronized-和-ReenTrantLock-的区别"><a href="#三-谈谈-synchronized-和-ReenTrantLock-的区别" class="headerlink" title="三 谈谈 synchronized 和 ReenTrantLock 的区别"></a>三 谈谈 synchronized 和 ReenTrantLock 的区别</h1><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p><p><strong>④ 两者的性能已经相差无几</strong></p><p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量岁线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。</p><h1 id="四-线程池了解吗？"><a href="#四-线程池了解吗？" class="headerlink" title="四 线程池了解吗？"></a>四 线程池了解吗？</h1><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1 为什么要用线程池？"></a>4.1 为什么要用线程池？</h3><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 </p><p>这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="4-2-Java-提供了哪几种线程池？他们各自的使用场景是什么？"><a href="#4-2-Java-提供了哪几种线程池？他们各自的使用场景是什么？" class="headerlink" title="4.2 Java 提供了哪几种线程池？他们各自的使用场景是什么？"></a>4.2 Java 提供了哪几种线程池？他们各自的使用场景是什么？</h3><h4 id="Java-主要提供了下面4种线程池"><a href="#Java-主要提供了下面4种线程池" class="headerlink" title="Java 主要提供了下面4种线程池"></a>Java 主要提供了下面4种线程池</h4><ul><li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong>ScheduledThreadPoolExecutor：</strong>主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor又分为：ScheduledThreadPoolExecutor（包含多个线程）和SingleThreadScheduledExecutor （只包含一个线程）两种。</li></ul><h4 id="各种线程池的适用场景介绍"><a href="#各种线程池的适用场景介绍" class="headerlink" title="各种线程池的适用场景介绍"></a>各种线程池的适用场景介绍</h4><ul><li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li><li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。</li><li><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</li><li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景，</li><li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li></ul><h3 id="4-3-创建的线程池的方式"><a href="#4-3-创建的线程池的方式" class="headerlink" title="4.3 创建的线程池的方式"></a>4.3 创建的线程池的方式</h3><p><strong>（1） 使用 Executors 创建</strong></p><p>我们上面刚刚提到了 Java 提供的几种线程池，通过 Executors 工具类我们可以很轻松的创建我们上面说的几种线程池。但是实际上我们一般都不是直接使用Java提供好的线程池，另外在《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors 返回线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</span><br></pre></td></tr></table></figure><p><strong>（2） ThreadPoolExecutor的构造函数创建</strong></p><p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">13</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">13</span>));</span><br></pre></td></tr></table></figure><p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p><p><strong>（3） 使用开源类库</strong></p><p>Hollis 大佬之前在他的文章中也提到了：“除了自己定义ThreadPoolExecutor外。还有其他方法。这个时候第一时间就应该想到开源类库，如apache和guava等。”他推荐使用guava提供的ThreadFactoryBuilder来创建线程池。下面是参考他的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方式创建线程时，不仅可以避免OOM的问题，还可以自定义线程名称，更加方便的出错的时候溯源。</p><h1 id="五-Nginx"><a href="#五-Nginx" class="headerlink" title="五 Nginx"></a>五 Nginx</h1><h3 id="5-1-简单介绍一下Nginx"><a href="#5-1-简单介绍一下Nginx" class="headerlink" title="5.1 简单介绍一下Nginx"></a>5.1 简单介绍一下Nginx</h3><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 Nginx  主要提供反向代理、负载均衡、动静分离(静态资源服务)等服务。下面我简单地介绍一下这些名词。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>谈到反向代理，就不得不提一下正向代理。无论是正向代理，还是反向代理，说到底，就是代理模式的衍生版本罢了</p><ul><li><strong>正向代理：</strong>某些情况下，代理我们用户去访问服务器，需要用户手动的设置代理服务器的ip和端口号。正向代理比较常见的一个例子就是 VPN了。</li><li><strong>反向代理：</strong> 是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</li></ul><p>通过下面两幅图，大家应该更好理解（图源：<a href="http://blog.720ui.com/2016/nginx_action_05_proxy/）：" target="_blank" rel="noopener">http://blog.720ui.com/2016/nginx_action_05_proxy/）：</a></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/60925795.jpg" alt="正向代理"></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/62563930.jpg" alt="反向代理"></p><p>所以，简单的理解，就是正向代理是为客户端做代理，代替客户端去访问服务器，而反向代理是为服务器做代理，代替服务器接受客户端请求。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。</p><p>Nginx支持的weight轮询（默认）、ip_hash、fair、url_hash这四种负载均衡调度算法，感兴趣的可以自行查阅。</p><p>负载均衡相比于反向代理更侧重的时将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。</p><h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><h3 id="5-2-为什么要用-Nginx-？"><a href="#5-2-为什么要用-Nginx-？" class="headerlink" title="5.2 为什么要用 Nginx ？"></a>5.2 为什么要用 Nginx ？</h3><blockquote><p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" target="_blank" rel="noopener">Nginx核心知识100讲的内容</a>。</p></blockquote><p>如果面试官问你这个问题，就一定想看你知道 Nginx 服务器的一些优点吗。</p><p>Nginx 有以下5个优点：</p><ol><li>高并发、高性能（这是其他web服务器不具有的）</li><li>可扩展性好（模块化设计，第三方插件生态圈丰富）</li><li>高可靠性（可以在服务器行持续不间断的运行数年）</li><li>热部署（这个功能对于 Nginx 来说特别重要，热部署指可以在不停止 Nginx服务的情况下升级 Nginx）</li><li>BSD许可证（意味着我们可以将源代码下载下来进行修改然后使用自己的版本）</li></ol><h3 id="5-3-Nginx-的四个主要组成部分了解吗？"><a href="#5-3-Nginx-的四个主要组成部分了解吗？" class="headerlink" title="5.3  Nginx 的四个主要组成部分了解吗？"></a>5.3  Nginx 的四个主要组成部分了解吗？</h3><blockquote><p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" target="_blank" rel="noopener">Nginx核心知识100讲的内容</a>。</p></blockquote><ul><li>Nginx 二进制可执行文件：由各模块源码编译出一个文件</li><li>Nginx.conf 配置文件：控制Nginx 行为</li><li>acess.log 访问日志： 记录每一条HTTP请求信息</li><li>error.log 错误日志:定位问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-object类有哪些方法&quot;&gt;一. Object类有哪些方法?&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-object类的常见方法总结&quot;&gt;1.1 Object类的常见方法总结&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8Markdown%E5%86%99%E4%B8%80%E4%BB%BD%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2019/01/17/手把手教你用Markdown写一份高质量的简历/</id>
    <published>2019-01-17T14:37:08.469Z</published>
    <updated>2019-01-14T05:35:11.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown-简历模板样式一览"><a href="#Markdown-简历模板样式一览" class="headerlink" title="Markdown 简历模板样式一览"></a>Markdown 简历模板样式一览</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f91e4843bd67?w=800&amp;h=1737&amp;f=png&amp;s=97357" alt=""><br><strong>可以看到我把联系方式放在第一位，因为公司一般会与你联系，所以把联系方式放在第一位也是为了方便联系考虑。</strong></p><h2 id="为什么要用-Markdown-写简历？"><a href="#为什么要用-Markdown-写简历？" class="headerlink" title="为什么要用 Markdown 写简历？"></a>为什么要用 Markdown 写简历？</h2><p>Markdown 语法简单，易于上手。使用正确的 Markdown 语言写出来的简历不论是在排版还是格式上都比较干净，易于阅读。另外，使用 Markdown 写简历也会给面试官一种你比较专业的感觉。</p><p>除了这些，我觉得使用 Markdown 写简历可以很方便将其与PDF、HTML、PNG格式之间转换。后面我会介绍到转换方法，只需要一条命令你就可以实现 Markdown 到 PDF、HTML 与 PNG之间的无缝切换。</p><blockquote><p>下面的一些内容我在之前的一篇文章中已经提到过，这里再说一遍，最后会分享如何实现Markdown 到 PDF、HTML、PNG格式之间转换。</p></blockquote><h2 id="为什么说简历很重要？"><a href="#为什么说简历很重要？" class="headerlink" title="为什么说简历很重要？"></a>为什么说简历很重要？</h2><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p><p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p><p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p><h2 id="写简历的两大法则"><a href="#写简历的两大法则" class="headerlink" title="写简历的两大法则"></a>写简历的两大法则</h2><p>目前写简历的方式有两种普遍被认可，一种是 STAR， 一种是 FAB。</p><p><strong>STAR法则（Situation Task Action Result）：</strong></p><ul><li><strong>Situation：</strong> 事情是在什么情况下发生；</li><li><strong>Task:：</strong> 你是如何明确你的任务的；</li><li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li><li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li></ul><p><strong>FAB 法则（Feature Advantage Benefit）：</strong></p><ul><li><strong>Feature：</strong> 是什么；</li><li><strong>Advantage：</strong> 比别人好在哪些地方；</li><li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li></ul><h2 id="项目经历怎么写？"><a href="#项目经历怎么写？" class="headerlink" title="项目经历怎么写？"></a>项目经历怎么写？</h2><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p><ol><li>对项目整体设计的一个感受</li><li>在这个项目中你负责了什么、做了什么、担任了什么角色</li><li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li><li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li></ol><h2 id="专业技能该怎么写？"><a href="#专业技能该怎么写？" class="headerlink" title="专业技能该怎么写？"></a>专业技能该怎么写？</h2><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写：</p><ul><li>Dubbo：精通</li><li>Spring：精通</li><li>Docker：掌握</li><li>SOA分布式开发 ：掌握</li><li>Spring Cloud:了解</li></ul><h2 id="简历模板分享"><a href="#简历模板分享" class="headerlink" title="简历模板分享"></a>简历模板分享</h2><p><strong>开源程序员简历模板</strong>： <a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a>（包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板）</p><p><strong>上述简历模板的改进版本：</strong> <a href="https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md</a> </p><h2 id="其他的一些小tips"><a href="#其他的一些小tips" class="headerlink" title="其他的一些小tips"></a>其他的一些小tips</h2><ol><li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li><li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li><li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li><li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li><li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li><li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li><li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li><li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li></ol><blockquote><p>我们刚刚讲了很多关于如何写简历的内容并且分享了一份 Markdown 格式的简历文档。下面我们来看看如何实现 Markdown 到 HTML格式、PNG格式之间转换。</p></blockquote><h2 id="Markdown-到-HTML格式、PNG格式之间转换"><a href="#Markdown-到-HTML格式、PNG格式之间转换" class="headerlink" title="Markdown 到 HTML格式、PNG格式之间转换"></a>Markdown 到 HTML格式、PNG格式之间转换</h2><p>网上很难找到一个比较方便并且效果好的转换方法，最后我是通过 Visual Studio Code 的 Markdown PDF 插件完美解决了这个问题！</p><h3 id="安装-Markdown-PDF-插件"><a href="#安装-Markdown-PDF-插件" class="headerlink" title="安装 Markdown PDF 插件"></a>安装 Markdown PDF 插件</h3><p><strong>① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9a44103e551?w=1366&amp;h=688&amp;f=png&amp;s=104435" alt="① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项"></p><p><strong>② 搜索 “Markdown PDF” 插件并安装 ，然后重启</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9dbef0d06fb?w=1280&amp;h=420&amp;f=png&amp;s=70510" alt="② 搜索 “Markdown PDF” 插件并安装 ，然后重启"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>随便打开一份 Markdown 文件 点击F1，然后输入export即可！</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659fa0292906150?w=1289&amp;h=468&amp;f=png&amp;s=72178" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Markdown-简历模板样式一览&quot;&gt;&lt;a href=&quot;#Markdown-简历模板样式一览&quot; class=&quot;headerlink&quot; title=&quot;Markdown 简历模板样式一览&quot;&gt;&lt;/a&gt;Markdown 简历模板样式一览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/interviewPrepare/"/>
    <id>http://yoursite.com/2019/01/17/interviewPrepare/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.702Z</updated>
    
    <content type="html"><![CDATA[<p>这是【备战春招/秋招系列】的第二篇文章，主要是简单地介绍如何去准备面试。</p><p>不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 我其实特别不喜欢那种临近考试就提前背啊记啊各种题的行为，非常反对！我觉得这种方法特别极端，而且在稍有一点经验的面试官面前是根本没有用的。建议大家还是一步一个脚印踏踏实实地走。</p><h3 id="1-如何获取大厂面试机会？"><a href="#1-如何获取大厂面试机会？" class="headerlink" title="1  如何获取大厂面试机会？"></a>1  如何获取大厂面试机会？</h3><p><strong>在讲如何获取大厂面试机会之前，先来给大家科普/对比一下两个校招非常常见的概念——春招和秋招。</strong></p><ol><li><strong>招聘人数</strong> ：秋招多于春招 ；</li><li><strong>招聘时间</strong> ： 秋招一般7月左右开始，大概一直持续到10月底。<font color="red">但是大厂（如BAT）都会早开始早结束，所以一定要把握好时间。</font>春招最佳时间为3月，次佳时间为4月，进入5月基本就不会再有春招了（金三银四）。  </li><li><strong>应聘难度</strong> ：秋招略大于春招；</li><li><strong>招聘公司：</strong>  秋招数量多，而春招数量较少，一般为秋招的补充。 </li></ol><p><strong>综上，一般来说，秋招的含金量明显是高于春招的。</strong></p><p><strong>下面我就说一下我自己知道的一些方法，不过应该也涵盖了大部分获取面试机会的方法。</strong></p><ol><li><strong>关注大厂官网，随时投递简历（走流程的网申）；</strong></li><li><strong>线下参加宣讲会，直接投递简历；</strong></li><li><strong>找到师兄师姐/认识的人，帮忙内推（能够让你避开网申简历筛选，笔试筛选，还是挺不错的，不过也还是需要你的简历够棒）；</strong></li><li><strong>博客发文被看中/Github优秀开源项目作者，大厂内部人员邀请你面试；</strong></li><li><strong>求职类网站投递简历（不是太推荐，适合海投）；</strong></li></ol><p>除了这些方法，我也遇到过这样的经历：有些大公司的一些部门可能暂时没招够人，然后如果你的亲戚或者朋友刚好在这个公司，而你正好又在寻求offer，那么面试机会基本上是有了，而且这种面试的难度好像一般还普遍比其他正规面试低很多。</p><h3 id="2-面试前的准备"><a href="#2-面试前的准备" class="headerlink" title="2  面试前的准备"></a>2  面试前的准备</h3><h3 id="2-1-准备自己的自我介绍"><a href="#2-1-准备自己的自我介绍" class="headerlink" title="2.1 准备自己的自我介绍"></a>2.1 准备自己的自我介绍</h3><p>从HR面、技术面到高管面/部门主管面，面试官一般会让你先自我介绍一下，所以好好准备自己的自我介绍真的非常重要。网上一般建议的是准备好两份自我介绍：一份对hr说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节，项目经验，经历那些就一语带过。</p><p>我这里简单分享一下我自己的自我介绍的一个简单的模板吧：</p><blockquote><p>面试官，您好！我叫某某。大学时间我主要利用课外时间学习某某。在校期间参与过一个某某系统的开发，另外，自己学习过程中也写过很多系统比如某某系统。在学习之余，我比较喜欢通过博客整理分享自己所学知识。我现在是某某社区的认证作者，写过某某很不错的文章。另外，我获得过某某奖,我的Github上开源的某个项目已经有多少Star了。</p></blockquote><h3 id="2-2-关于着装"><a href="#2-2-关于着装" class="headerlink" title="2.2 关于着装"></a>2.2 关于着装</h3><p>穿西装、打领带、小皮鞋？NO！NO！NO！这是互联网公司面试又不是去走红毯，所以你只需要穿的简单大方就好，不需要太正式。</p><h3 id="2-3-随身带上自己的成绩单和简历"><a href="#2-3-随身带上自己的成绩单和简历" class="headerlink" title="2.3 随身带上自己的成绩单和简历"></a>2.3 随身带上自己的成绩单和简历</h3><p>有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。</p><h3 id="2-4-如果需要笔试就提前刷一些笔试题"><a href="#2-4-如果需要笔试就提前刷一些笔试题" class="headerlink" title="2.4 如果需要笔试就提前刷一些笔试题"></a>2.4 如果需要笔试就提前刷一些笔试题</h3><p>平时空闲时间多的可以刷一下笔试题目（牛客网上有很多）。但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。</p><h3 id="2-5-花时间一些逻辑题"><a href="#2-5-花时间一些逻辑题" class="headerlink" title="2.5 花时间一些逻辑题"></a>2.5 花时间一些逻辑题</h3><p>面试中发现有些公司都有逻辑题测试环节，并且都把逻辑笔试成绩作为很重要的一个参考。</p><h3 id="2-6-准备好自己的项目介绍"><a href="#2-6-准备好自己的项目介绍" class="headerlink" title="2.6 准备好自己的项目介绍"></a>2.6 准备好自己的项目介绍</h3><p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：</p><ol><li>对项目整体设计的一个感受（面试官可能会让你画系统的架构图）</li><li>在这个项目中你负责了什么、做了什么、担任了什么角色</li><li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li><li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li></ol><h3 id="2-7-提前准备技术面试"><a href="#2-7-提前准备技术面试" class="headerlink" title="2.7 提前准备技术面试"></a>2.7 提前准备技术面试</h3><p>搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问到、自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</p><h3 id="2-7-面试之前做好定向复习"><a href="#2-7-面试之前做好定向复习" class="headerlink" title="2.7 面试之前做好定向复习"></a>2.7 面试之前做好定向复习</h3><p>所谓定向复习就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</p><p>举个栗子：在我面试 ThoughtWorks 的前几天我就在网上找了一些关于 ThoughtWorks 的技术面的一些文章。然后知道了 ThoughtWorks 的技术面会让我们在之前做的作业的基础上增加一个或两个功能，所以我提前一天就把我之前做的程序重新重构了一下。然后在技术面的时候，简单的改了几行代码之后写个测试就完事了。如果没有提前准备，我觉得 20 分钟我很大几率会完不成这项任务。</p><h1 id="3-面试之后复盘"><a href="#3-面试之后复盘" class="headerlink" title="3 面试之后复盘"></a>3 面试之后复盘</h1><p>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是【备战春招/秋招系列】的第二篇文章，主要是简单地介绍如何去准备面试。&lt;/p&gt;
&lt;p&gt;不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 我其实特别不
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E7%BE%8E%E5%9B%A2-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>http://yoursite.com/2019/01/17/美团-进阶篇/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.719Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16711ac29c2ae52c?w=928&amp;h=531&amp;f=png&amp;s=798562" alt=" 【备战春招/秋招系列】美团面经总结进阶篇 （附详解答案）"><br><!-- MarkdownTOC --></p><ul><li><a href="#一-消息队列mq的套路">一 消息队列MQ的套路</a><ul><li><a href="#11-介绍一下消息队列mq的应用场景使用消息队列的好处">1.1  介绍一下消息队列MQ的应用场景/使用消息队列的好处</a><ul><li><a href="#①通过异步处理提高系统性能">①.通过异步处理提高系统性能</a></li><li><a href="#②降低系统耦合性">②.降低系统耦合性</a></li></ul></li><li><a href="#12-那么使用消息队列会带来什么问题考虑过这个问题吗">1.2 那么使用消息队列会带来什么问题？考虑过这个问题吗？</a></li><li><a href="#13-介绍一下你知道哪几种消息队列该如何选择呢">1.3 介绍一下你知道哪几种消息队列，该如何选择呢？</a></li><li><a href="#14-关于消息队列其他一些常见的问题展望">1.4 关于消息队列其他一些常见的问题展望</a></li></ul></li><li><a href="#二-谈谈-innodb-和-myisam-两者的区别">二 谈谈 InnoDB 和 MyIsam 两者的区别</a><ul><li><a href="#21-两者的对比">2.1 两者的对比</a></li><li><a href="#22-关于两者的总结">2.2 关于两者的总结</a></li></ul></li><li><a href="#三-聊聊-java-中的集合吧！">三 聊聊 Java 中的集合吧！</a><ul><li><a href="#31-arraylist-与-linkedlist-有什么不同？（注意加上从数据结构分析的内容）">3.1 Arraylist 与 LinkedList 有什么不同？（注意加上从数据结构分析的内容）</a></li><li><a href="#32-hashmap的底层实现">3.2 HashMap的底层实现</a><ul><li><a href="#①-jdk18之前">① JDK1.8之前</a></li></ul></li><li><a href="#②-jdk18之后">② JDK1.8之后</a></li><li><a href="#33-既然谈到了红黑树，你给我手绘一个出来吧，然后简单讲一下自己对于红黑树的理解">3.3 既然谈到了红黑树，你给我手绘一个出来吧，然后简单讲一下自己对于红黑树的理解</a></li><li><a href="#34-红黑树这么优秀为何不直接使用红黑树得了">3.4 红黑树这么优秀，为何不直接使用红黑树得了？</a></li><li><a href="#35-hashmap-和-hashtable-的区别hashset-和-hashmap-区别">3.5  HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别</a></li></ul></li></ul><!-- /MarkdownTOC --><blockquote><p>该文已加入开源文档：JavaGuide（一份涵盖大部分Java程序员所需要掌握的核心知识）。地址:<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a>.</p></blockquote><p><strong>系列文章：</strong></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484573&amp;idx=1&amp;sn=8c5965d4a3710d405d8e8cc10c7b0ce5&amp;chksm=fd9852fccaefdbea8dfe0bc40188b7579f1cddb1e8905dc981669a3f21d2a04cadceafa9023f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列1】程序员的简历就该这样写</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484592&amp;idx=1&amp;sn=6d9731ce7401be49e97c1af6ed384ecc&amp;chksm=fd9852d1caefdbc720a361ae65a8ad9d53cfb4800b15a7c68cbdc630b313215c6c52e0934ec2&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列3】Java程序员必备书单</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484601&amp;idx=1&amp;sn=4907b7fef0856791c565d49d788ba8cc&amp;chksm=fd9852d8caefdbce88e51c0a10a4ec77c97f382fd2af4a840ea47cffc828bfd0f993f50d5f0d&amp;token=2045370425&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列4】美团面经总结基础篇 （附详解答案）</a></li></ul><p>这是我总结的美团面经的进阶篇，后面还有终结篇哦！下面只是我从很多份美团面经中总结的在美团面试中一些常见的问题。不同于个人面经，这份面经具有普适性。每次面试必备的自我介绍、项目介绍这些东西，大家可以自己私下好好思考。我在前面的文章中也提到了应该怎么做自我介绍与项目介绍，详情可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a>。</p><p>有人私信我让我对美团面试难度做一个评级，我觉得如果有10级的话，美团面试的难度大概在6级左右吧！部分情况可能因人而异了。</p><blockquote><p>消息队列/消息中间件应该是Java程序员必备的一个技能了，如果你之前没接触过消息队列的话，建议先去百度一下某某消息队列入门，然后花2个小时就差不多可以学会任何一种消息队列的使用了。如果说仅仅学会使用是万万不够的，在实际生产环境还要考虑消息丢失等等情况。关于消息队列面试相关的问题，推荐大家也可以看一下视频《Java工程师面试突击第1季-中华石杉老师》，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！</p></blockquote><h1 id="一-消息队列MQ的套路"><a href="#一-消息队列MQ的套路" class="headerlink" title="一 消息队列MQ的套路"></a>一 消息队列MQ的套路</h1><blockquote><p>面试官一般会先问你这个问题，预热一下，看你知道消息队列不，一般在第一面的时候面试官可能只会问消息队列MQ的应用场景/使用消息队列的好处、使用消息队列会带来什么问题、消息队列的技术选型这几个问题，不会太深究下去，在后面的第二轮/第三轮技术面试中可能会深入问一下。</p></blockquote><h3 id="1-1-介绍一下消息队列MQ的应用场景-使用消息队列的好处"><a href="#1-1-介绍一下消息队列MQ的应用场景-使用消息队列的好处" class="headerlink" title="1.1  介绍一下消息队列MQ的应用场景/使用消息队列的好处"></a>1.1  介绍一下消息队列MQ的应用场景/使用消息队列的好处</h3><p><strong>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</strong></p><h4 id="①-通过异步处理提高系统性能"><a href="#①-通过异步处理提高系统性能" class="headerlink" title="①.通过异步处理提高系统性能"></a>①.通过异步处理提高系统性能</h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e63a8e34ba534?w=910&amp;h=350&amp;f=jpeg&amp;s=29123" alt="通过异步处理提高系统性能"><br>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p><p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e64583dd3ed01?w=780&amp;h=384&amp;f=jpeg&amp;s=13550" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击"><br>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h3 id="②-降低系统耦合性"><a href="#②-降低系统耦合性" class="headerlink" title="②.降低系统耦合性"></a>②.降低系统耦合性</h3><p>我们知道模块分布式部署以后聚合方式通常有两种：1.<strong>分布式消息队列</strong>和2.<strong>分布式服务</strong>。</p><blockquote><p><strong>先来简单说一下分布式服务：</strong></p></blockquote><p>目前使用比较多的用来构建<strong>SOA（Service Oriented Architecture面向服务体系结构）</strong>的<strong>分布式服务框架</strong>是阿里巴巴开源的<strong>Dubbo</strong>.如果想深入了解Dubbo的可以看我写的关于Dubbo的这一篇文章：<strong>《高性能优秀的服务框架-dubbo介绍》</strong>：<a href="https://juejin.im/post/5acadeb1f265da2375072f9c" target="_blank" rel="noopener">https://juejin.im/post/5acadeb1f265da2375072f9c</a></p><blockquote><p><strong>再来谈我们的分布式消息队列：</strong></p></blockquote><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6665fa394b3b?w=790&amp;h=290&amp;f=jpeg&amp;s=14946" alt="利用消息队列实现事件驱动结构"><br><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong>   </p><p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<strong>比如在我们的ActiveMQ消息队列中还有点对点工作模式</strong>，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。</p><blockquote><p>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！</p></blockquote><h3 id="1-2-那么使用消息队列会带来什么问题？考虑过这个问题吗？"><a href="#1-2-那么使用消息队列会带来什么问题？考虑过这个问题吗？" class="headerlink" title="1.2 那么使用消息队列会带来什么问题？考虑过这个问题吗？"></a>1.2 那么使用消息队列会带来什么问题？考虑过这个问题吗？</h3><ul><li><strong>系统可用性降低：</strong>系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><blockquote><p>了解下面这个问题是为了我们更好的进行技术选型！该部分摘自：《Java工程师面试突击第1季-中华石杉老师》，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！</p></blockquote><h3 id="1-3-介绍一下你知道哪几种消息队列，该如何选择呢？"><a href="#1-3-介绍一下你知道哪几种消息队列，该如何选择呢？" class="headerlink" title="1.3 介绍一下你知道哪几种消息队列，该如何选择呢？"></a>1.3 介绍一下你知道哪几种消息队列，该如何选择呢？</h3><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:right">ActiveMQ</th><th style="text-align:right">RabbitMQ</th><th style="text-align:right">RocketMQ</th><th style="text-align:right">Kafaka</th></tr></thead><tbody><tr><td style="text-align:left">单机吞吐量</td><td style="text-align:right">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td><td style="text-align:right">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td><td style="text-align:right">10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td><td style="text-align:right">10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td style="text-align:left">topic数量对吞吐量的影响</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right">topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td><td style="text-align:right">topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td></tr><tr><td style="text-align:left">可用性</td><td style="text-align:right">高，基于主从架构实现高可用性</td><td style="text-align:right">高，基于主从架构实现高可用性</td><td style="text-align:right">非常高，分布式架构</td><td style="text-align:right">非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td style="text-align:left">消息可靠性</td><td style="text-align:right">有较低的概率丢失数据</td><td style="text-align:right"></td><td style="text-align:right">经过参数优化配置，可以做到0丢失</td><td style="text-align:right">经过参数优化配置，消息可以做到0丢失</td></tr><tr><td style="text-align:left">时效性</td><td style="text-align:right">ms级</td><td style="text-align:right">微秒级，这是rabbitmq的一大特点，延迟是最低的</td><td style="text-align:right">ms级</td><td style="text-align:right">延迟在ms级以内</td></tr><tr><td style="text-align:left">功能支持</td><td style="text-align:right">MQ领域的功能极其完备</td><td style="text-align:right">基于erlang开发，所以并发能力很强，性能极其好，延时很低</td><td style="text-align:right">MQ功能较为完善，还是分布式的，扩展性好</td><td style="text-align:right">功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td style="text-align:left">优劣势总结</td><td style="text-align:right">非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td><td style="text-align:right">erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用rabbitmq也比较多一些但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</td><td style="text-align:right">接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控。社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</td><td style="text-align:right">kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</td></tr></tbody></table><blockquote><p>这部分内容，我这里不给出答案，大家可以自行根据自己学习的消息队列查阅相关内容，我可能会在后面的文章中介绍到这部分内容。另外，下面这些问题在视频《Java工程师面试突击第1季-中华石杉老师》中都有提到，如果大家没有资源的话，可以在我的公众号“Java面试通关手册”后台回复关键字“1”即可！</p></blockquote><h3 id="1-4-关于消息队列其他一些常见的问题展望"><a href="#1-4-关于消息队列其他一些常见的问题展望" class="headerlink" title="1.4 关于消息队列其他一些常见的问题展望"></a>1.4 关于消息队列其他一些常见的问题展望</h3><ol><li>引入消息队列之后如何保证高可用性</li><li>如何保证消息不被重复消费呢？</li><li>如何保证消息的可靠性传输（如何处理消息丢失的问题）？</li><li>我该怎么保证从消息队列里拿到的数据按顺序执行？</li><li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</li><li>如果让你来开发一个消息队列中间件，你会怎么设计架构？</li></ol><h1 id="二-谈谈-InnoDB-和-MyIsam-两者的区别"><a href="#二-谈谈-InnoDB-和-MyIsam-两者的区别" class="headerlink" title="二 谈谈 InnoDB 和 MyIsam 两者的区别"></a>二 谈谈 InnoDB 和 MyIsam 两者的区别</h1><h3 id="2-1-两者的对比"><a href="#2-1-两者的对比" class="headerlink" title="2.1 两者的对比"></a>2.1 两者的对比</h3><p>1) <strong>count运算上的区别：</strong> 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。</p><p>2) <strong>是否支持事务和崩溃后的安全恢复：</strong> MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><p>3)<strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</p><h3 id="2-2-关于两者的总结"><a href="#2-2-关于两者的总结" class="headerlink" title="2.2 关于两者的总结"></a>2.2 关于两者的总结</h3><p>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。</p><p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。</p><h1 id="三-聊聊-Java-中的集合吧！"><a href="#三-聊聊-Java-中的集合吧！" class="headerlink" title="三 聊聊 Java 中的集合吧！"></a>三 聊聊 Java 中的集合吧！</h1><h3 id="3-1-Arraylist-与-LinkedList-有什么不同？（注意加上从数据结构分析的内容）"><a href="#3-1-Arraylist-与-LinkedList-有什么不同？（注意加上从数据结构分析的内容）" class="headerlink" title="3.1 Arraylist 与 LinkedList 有什么不同？（注意加上从数据结构分析的内容）"></a>3.1 Arraylist 与 LinkedList 有什么不同？（注意加上从数据结构分析的内容）</h3><ul><li><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（注意双向链表和双向循环链表的区别：）；</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>4. 是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 </li></ul><p><strong>补充内容:RandomAccess接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArraysList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArraysList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArraysList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArraysList 实现 RandomAccess 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,</li><li>未实现RandomAccess接口的ist， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环</li></ul><blockquote><p>Java 中的集合这类问题几乎是面试必问的，问到这类问题的时候，HashMap 又是几乎必问的问题，所以大家一定要引起重视！</p></blockquote><h3 id="3-2-HashMap的底层实现"><a href="#3-2-HashMap的底层实现" class="headerlink" title="3.2 HashMap的底层实现"></a>3.2 HashMap的底层实现</h3><h4 id="①-JDK1-8之前"><a href="#①-JDK1-8之前" class="headerlink" title="① JDK1.8之前"></a>① JDK1.8之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&amp;h=427&amp;f=png&amp;s=10991" alt="jdk1.8之前的内部结构"></p><h4 id="②-JDK1-8之后"><a href="#②-JDK1-8之后" class="headerlink" title="② JDK1.8之后"></a>② JDK1.8之后</h4><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16711ac29c351da9?w=720&amp;h=545&amp;f=jpeg&amp;s=23933" alt="JDK1.8之后的HashMap底层数据结构"></p><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><blockquote><p>问完 HashMap 的底层原理之后，面试官可能就会紧接着问你 HashMap 底层数据结构相关的问题！</p></blockquote><h3 id="3-3-既然谈到了红黑树，你给我手绘一个出来吧，然后简单讲一下自己对于红黑树的理解"><a href="#3-3-既然谈到了红黑树，你给我手绘一个出来吧，然后简单讲一下自己对于红黑树的理解" class="headerlink" title="3.3 既然谈到了红黑树，你给我手绘一个出来吧，然后简单讲一下自己对于红黑树的理解"></a>3.3 既然谈到了红黑树，你给我手绘一个出来吧，然后简单讲一下自己对于红黑树的理解</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16711ac29c138cba?w=851&amp;h=614&amp;f=jpeg&amp;s=34458" alt="红黑树"></p><p><strong>红黑树特点:</strong></p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ol><p><strong>红黑树的应用：</strong></p><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。</p><p><strong>为什么要用红黑树</strong></p><p>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><h3 id="3-4-红黑树这么优秀，为何不直接使用红黑树得了？"><a href="#3-4-红黑树这么优秀，为何不直接使用红黑树得了？" class="headerlink" title="3.4 红黑树这么优秀，为何不直接使用红黑树得了？"></a>3.4 红黑树这么优秀，为何不直接使用红黑树得了？</h3><p>说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。</p><h3 id="3-5-HashMap-和-Hashtable-的区别-HashSet-和-HashMap-区别"><a href="#3-5-HashMap-和-Hashtable-的区别-HashSet-和-HashMap-区别" class="headerlink" title="3.5  HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别"></a>3.5  HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别</h3><p><strong>HashMap 和 Hashtable 的区别</strong></p><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过  <code>synchronized</code>  修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong>   ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashSet 和 HashMap 区别</strong></p><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。）</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?w=896&amp;h=363&amp;f=jpeg&amp;s=205536" alt="HashSet 和 HashMap 区别"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/16711ac29c2ae52c?w=928&amp;amp;h=531&amp;amp;f=png&amp;amp;s=798562&quot; alt=&quot; 【备战春招/秋招系列】美团面经总结进阶篇 （附
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/JavaInterviewGithub/"/>
    <id>http://yoursite.com/2019/01/17/JavaInterviewGithub/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.699Z</updated>
    
    <content type="html"><![CDATA[<p>最近浏览 Github ，收藏了一些还算不错的 Java面试/学习相关的仓库，分享给大家，希望对你有帮助。我暂且按照目前的 Star 数量来排序。</p><p>本文由 SnailClimb 整理，如需转载请联系作者。</p><h3 id="1-interviews"><a href="#1-interviews" class="headerlink" title="1. interviews"></a>1. interviews</h3><ul><li>Github地址:                     <a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md" target="_blank" rel="noopener">https://github.com/kdn251/interviews/blob/master/README-zh-cn.md</a></li><li>star: 31k</li><li>介绍: 软件工程技术面试个人指南。</li><li><p>概览：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-24/47663247.jpg" alt="interviews"></p></li></ul><h3 id="2-JCSprout"><a href="#2-JCSprout" class="headerlink" title="2. JCSprout"></a>2. JCSprout</h3><ul><li>Github地址：<a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">https://github.com/crossoverJie/JCSprout</a></li><li>star: 17.7k</li><li>介绍: Java Core Sprout：处于萌芽阶段的 Java 核心知识库。</li><li><p>概览：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-24/85903384.jpg" alt=" JCSprout"></p></li></ul><h3 id="3-JavaGuide"><a href="#3-JavaGuide" class="headerlink" title="3. JavaGuide"></a>3. JavaGuide</h3><ul><li>Github地址： <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></li><li>star: 17.4k</li><li>介绍: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。</li><li><p>概览：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-24/1352784.jpg" alt="JavaGuide"></p></li></ul><h3 id="4-technology-talk"><a href="#4-technology-talk" class="headerlink" title="4. technology-talk"></a>4. technology-talk</h3><ul><li>Github地址： <a href="https://github.com/aalansehaiyang/technology-talk" target="_blank" rel="noopener">https://github.com/aalansehaiyang/technology-talk</a></li><li>star: 4.2k</li><li>介绍: 汇总java生态圈常用技术框架、开源中间件，系统架构、项目管理、经典架构案例、数据库、常用三方库、线上运维等知识。</li></ul><h3 id="5-fullstack-tutorial"><a href="#5-fullstack-tutorial" class="headerlink" title="5. fullstack-tutorial"></a>5. fullstack-tutorial</h3><ul><li>Github地址： <a href="https://github.com/frank-lam/fullstack-tutorial" target="_blank" rel="noopener">https://github.com/frank-lam/fullstack-tutorial</a></li><li>star: 2.8k</li><li>介绍:  Full Stack Developer Tutorial，后台技术栈/全栈开发/架构师之路，秋招/春招/校招/面试。 from zero to hero。</li><li><p>概览：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-24/67104534.jpg" alt="fullstack-tutorial"></p></li></ul><h3 id="6-java-bible"><a href="#6-java-bible" class="headerlink" title="6. java-bible"></a>6. java-bible</h3><ul><li>Github地址：<a href="https://github.com/biezhi/java-bible" target="_blank" rel="noopener">https://github.com/biezhi/java-bible</a></li><li>star: 1.9k</li><li>介绍:  这里记录了一些技术摘要，部分文章来自网络，本项目的目的力求分享精品技术干货，以Java为主。</li><li><p>概览：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-24/90223588.jpg" alt=" java-bible"></p></li></ul><h3 id="7-EasyJob"><a href="#7-EasyJob" class="headerlink" title="7. EasyJob"></a>7. EasyJob</h3><ul><li>Github地址：<a href="https://github.com/it-interview/EasyJob" target="_blank" rel="noopener">https://github.com/it-interview/EasyJob</a></li><li>star: 1.9k</li><li>介绍:  互联网求职面试题、知识点和面经整理。</li></ul><h3 id="8-advanced-java"><a href="#8-advanced-java" class="headerlink" title="8. advanced-java"></a>8. advanced-java</h3><ul><li>Github地址：<a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">https://github.com/doocs/advanced-java</a></li><li>star: 1k</li><li>介绍: 互联网 Java 工程师进阶知识完全扫盲</li></ul><h3 id="9-3y"><a href="#9-3y" class="headerlink" title="9. 3y"></a>9. 3y</h3><ul><li>Github地址：<a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">https://github.com/ZhongFuCheng3y/3y</a></li><li>star: 0.4 k</li><li>介绍: Java 知识整合。</li></ul><p>除了这九个仓库，再推荐几个不错的学习方向的仓库给大家。</p><ol><li>Star 数高达 4w+的 CS 笔记-CS-Notes：<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li><li>后端（尤其是Java）程序员的 Linux 学习仓库-Linux-Tutorial：<a href="https://github.com/judasn/Linux-Tutorial" target="_blank" rel="noopener">https://github.com/judasn/Linux-Tutorial</a>( Star:4.6k)</li><li>两个算法相关的仓库，刷 Leetcode 的小伙伴必备：①awesome-java-leetcode：<a href="https://github.com/Blankj/awesome-java-leetcode" target="_blank" rel="noopener">https://github.com/Blankj/awesome-java-leetcode</a>；②LintCode：<a href="https://github.com/awangdev/LintCode" target="_blank" rel="noopener">https://github.com/awangdev/LintCode</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近浏览 Github ，收藏了一些还算不错的 Java面试/学习相关的仓库，分享给大家，希望对你有帮助。我暂且按照目前的 Star 数量来排序。&lt;/p&gt;
&lt;p&gt;本文由 SnailClimb 整理，如需转载请联系作者。&lt;/p&gt;
&lt;h3 id=&quot;1-interviews&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/java%20programmer%20need%20know/"/>
    <id>http://yoursite.com/2019/01/17/java programmer need know/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.703Z</updated>
    
    <content type="html"><![CDATA[<p>　　身边的朋友或者公众号的粉丝很多人都向我询问过:“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学那些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分人关心的这些问题进行答疑解惑。现在又刚好赶上考研结束，这篇文章也算是给考研结束准备往Java后端方向发展的朋友们指名一条学习之路。道理懂了如果没有实际行动，那这篇文章对你或许没有任何意义。</p><h3 id="Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？"><a href="#Question1-我是双非-三本-专科学校的，我有机会进入大厂吗？" class="headerlink" title="Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？"></a>Question1:我是双非/三本/专科学校的，我有机会进入大厂吗？</h3><p>　　我自己也是非985非211学校的，结合自己的经历以及一些朋友的经历，我觉得让我回答这个问题再好不过。</p><p>　　首先，我觉得学校歧视很正常，真的太正常了，如果要抱怨的话，你只能抱怨自己没有进入名校。但是，千万不要动不动说自己学校差，动不动拿自己学校当做自己进不了大厂的借口，学历只是筛选简历的很多标准中的一个而已，如果你够优秀，简历够丰富，你也一样可以和名校同学一起同台竞争。</p><p>　　企业HR肯定是更喜欢高学历的人，毕竟985，211优秀人才比例肯定比普通学校高很多，HR团队肯定会优先在这些学校里选。这就好比相亲，你是愿意在很多优秀的人中选一个优秀的，还是愿意在很多普通的人中选一个优秀的呢？<br>　　<br>　　双非本科甚至是二本、三本甚至是专科的同学也有很多进入大厂的，不过比率相比于名校的低很多而已。从大厂招聘的结果上看，高学历人才的数量占据大头，那些成功进入BAT、美团，京东，网易等大厂的双非本科甚至是二本、三本甚至是专科的同学往往是因为具备丰富的项目经历或者在某个含金量比较高的竞赛比如ACM中取得了不错的成绩。<strong>一部分学历不突出但能力出众的面试者能够进入大厂并不是说明学历不重要，而是学历的软肋能够通过其他的优势来弥补。</strong> 所以，如果你的学校不够好而你自己又想去大厂的话，建议你可以从这几点来做：<strong>①尽量在面试前最好有一个可以拿的出手的项目；②有实习条件的话，尽早出去实习，实习经历也会是你的简历的一个亮点（有能力在大厂实习最佳！）；③参加一些含金量比较高的比赛，拿不拿得到名次没关系，重在锻炼。</strong></p><h3 id="Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？"><a href="#Question2-非计算机专业的学生能学好Java后台吗？我能进大厂吗？" class="headerlink" title="Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？"></a>Question2:非计算机专业的学生能学好Java后台吗？我能进大厂吗？</h3><p>　　当然可以！现在非科班的程序员很多，很大一部分原因是互联网行业的工资比较高。我们学校外面的培训班里面90%都是非科班，我觉得他们很多人学的都还不错。另外，我的一个朋友本科是机械专业，大一开始自学安卓，技术贼溜，在我看来他比大部分本科是计算机的同学学的还要好。参考Question1的回答，即使你是非科班程序员，如果你想进入大厂的话，你也可以通过自己的其他优势来弥补。</p><p>　　我觉得我们不应该因为自己的专业给自己划界限或者贴标签，说实话，很多科班的同学可能并不如你，你以为科班的同学就会认真听讲吗？还不是几乎全靠自己课下自学！不过如果你是非科班的话，你想要学好，那么注定就要舍弃自己本专业的一些学习时间，这是无可厚非的。</p><p>　　建议非科班的同学，首先要打好计算机基础知识基础：①计算机网络、②操作系统、③数据机构与算法，我个人觉得这3个对你最重要。这些东西就像是内功，对你以后的长远发展非常有用。当然，如果你想要进大厂的话，这些知识也是一定会被问到的。另外，“一定学好数据机构与算法！一定学好数据机构与算法！一定学好数据机构与算法！”，重要的东西说3遍。</p><h3 id="Question3-我没有实习经历的话找工作是不是特别艰难？"><a href="#Question3-我没有实习经历的话找工作是不是特别艰难？" class="headerlink" title="Question3: 我没有实习经历的话找工作是不是特别艰难？"></a>Question3: 我没有实习经历的话找工作是不是特别艰难？</h3><p>　　没有实习经历没关系，只要你有拿得出手的项目或者大赛经历的话，你依然有可能拿到大厂的 offer 。笔主当时找工作的时候就没有实习经历以及大赛获奖经历，单纯就是凭借自己的项目经验撑起了整个面试。</p><p>　　如果你既没有实习经历，又没有拿得出手的项目或者大赛经历的话，我觉得在简历关，除非你有其他特别的亮点，不然，你应该就会被刷。</p><h3 id="Question4-我该如何准备面试呢？面试的注意事项有哪些呢？"><a href="#Question4-我该如何准备面试呢？面试的注意事项有哪些呢？" class="headerlink" title="Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？"></a>Question4: 我该如何准备面试呢？面试的注意事项有哪些呢？</h3><p>下面是我总结的一些准备面试的Tips以及面试必备的注意事项：</p><ol><li><strong>准备一份自己的自我介绍，面试的时候根据面试对象适当进行修改</strong>（突出重点，突出自己的优势在哪里，切忌流水账）；</li><li><strong>注意随身带上自己的成绩单和简历复印件；</strong> （有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。）</li><li><strong>如果需要笔试就提前刷一些笔试题，大部分在线笔试的类型是选择题+编程题，有的还会有简答题。</strong>（平时空闲时间多的可以刷一下笔试题目（牛客网上有很多），但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。）另外，注意抓重点，因为题目太多了，但是有很多题目几乎次次遇到，像这样的题目一定要搞定。</li><li><strong>提前准备技术面试。</strong> 搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问到、自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li><li><strong>面试之前做好定向复习。</strong> 也就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</li><li><strong>准备好自己的项目介绍。</strong> 如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：①对项目整体设计的一个感受（面试官可能会让你画系统的架构图；②在这个项目中你负责了什么、做了什么、担任了什么角色；③ 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用；④项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li><li><strong>面试之后记得复盘。</strong> 面试遭遇失败是很正常的事情，所以善于总结自己的失败原因才是最重要的。如果失败，不要灰心；如果通过，切勿狂喜。</li></ol><p><strong>一些还算不错的 Java面试/学习相关的仓库，相信对大家准备面试一定有帮助：</strong><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484817&amp;idx=1&amp;sn=12f0c254a240c40c2ccab8314653216b&amp;chksm=fd9853f0caefdae6d191e6bf085d44ab9c73f165e3323aa0362d830e420ccbfad93aa5901021&amp;token=766994974&amp;lang=zh_CN#rd" target="_blank" rel="noopener">盘点一下Github上开源的Java面试/学习相关的仓库，看完弄懂薪资至少增加10k</a></p><h3 id="Question5-我该自学还是报培训班呢？"><a href="#Question5-我该自学还是报培训班呢？" class="headerlink" title="Question5: 我该自学还是报培训班呢？"></a>Question5: 我该自学还是报培训班呢？</h3><p>　　我本人更加赞同自学（你要知道去了公司可没人手把手教你了，而且几乎所有的公司都对培训班出生的有偏见。为什么有偏见，你学个东西还要去培训班，说明什么，同等水平下，你的自学能力以及自律能力一定是比不上自学的人的）。但是如果，你连每天在寝室坚持学上8个小时以上都坚持不了，或者总是容易半途而废的话，我还是推荐你去培训班。观望身边同学去培训班的，大多是非计算机专业或者是没有自律能力以及自学能力非常差的人。</p><p>　　另外，如果自律能力不行，你也可以通过结伴学习、参加老师的项目等方式来督促自己学习。</p><p>　　总结：去不去培训班主要还是看自己，如果自己能坚持自学就自学，坚持不下来就去培训班。</p><h3 id="Question6-没有项目经历-博客-Github开源项目怎么办？"><a href="#Question6-没有项目经历-博客-Github开源项目怎么办？" class="headerlink" title="Question6: 没有项目经历/博客/Github开源项目怎么办？"></a>Question6: 没有项目经历/博客/Github开源项目怎么办？</h3><p>　　从现在开始做！</p><p>　　网上有很多非常不错的项目视频，你就跟着一步一步做，不光要做，还要改进，改善。另外，如果你的老师有相关 Java 后台项目的话，你也可以主动申请参与进来。</p><p>　　如果有自己的博客，也算是简历上的一个亮点。建议可以在掘金、Segmentfault、CSDN等技术交流社区写博客，当然，你也可以自己搭建一个博客（采用 Hexo+Githu Pages 搭建非常简单）。写一些什么？学习笔记、实战内容、读书笔记等等都可以。</p><p>　　多用 Github，用好 Github，上传自己不错的项目，写好 readme 文档，在其他技术社区做好宣传。相信你也会收获一个不错的开源项目！</p><h3 id="Question7-大厂到底青睐什么样的应届生？"><a href="#Question7-大厂到底青睐什么样的应届生？" class="headerlink" title="Question7: 大厂到底青睐什么样的应届生？"></a>Question7: 大厂到底青睐什么样的应届生？</h3><p>　　从阿里、腾讯等大厂招聘官网对于Java后端方向/后端方向的应届实习生的要求，我们大概可以总结归纳出下面这 4 点能给简历增加很多分数：</p><ul><li>参加过竞赛（含金量超高的是ACM）；</li><li>对数据结构与算法非常熟练；</li><li>参与过实际项目（比如学校网站）；</li><li>参与过某个知名的开源项目或者自己的某个开源项目很不错；</li></ul><p>　　除了我上面说的这三点，在面试Java工程师的时候，下面几点也提升你的个人竞争力：</p><ul><li>熟悉Python、Shell、Perl等脚本语言；</li><li>熟悉 Java 优化，JVM调优；</li><li>熟悉 SOA 模式；</li><li>熟悉自己所用框架的底层知识比如Spring；</li><li>了解分布式一些常见的理论；</li><li>具备高并发开发经验；大数据开发经验等等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　身边的朋友或者公众号的粉丝很多人都向我询问过:“我是双非/三本/专科学校的，我有机会进入大厂吗？”、“非计算机专业的学生能学好吗？”、“如何学习Java？”、“Java学习该学那些东西？”、“我该如何准备Java面试？”……这些方面的问题。我会根据自己的一点经验对大部分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E7%BE%8E%E5%9B%A2-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2019/01/17/美团-基础篇/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.716Z</updated>
    
    <content type="html"><![CDATA[<!-- MarkdownTOC --><ul><li><a href="#1-systemoutprintln3-|-9输出什么">1.  <code>System.out.println(3 | 9);</code>输出什么？</a></li><li><a href="#2-说一下转发forward和重定向redirect的区别">2. 说一下转发(Forward)和重定向(Redirect)的区别</a></li><li><a href="#3-在浏览器中输入url地址到显示主页的过程整个过程会使用哪些协议">3.  在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</a></li><li><a href="#4-tcp-三次握手和四次挥手">4.  TCP 三次握手和四次挥手</a><ul><li><a href="#为什么要三次握手">为什么要三次握手</a></li><li><a href="#为什么要传回-syn">为什么要传回 SYN</a></li><li><a href="#传了-syn为啥还要传-ack">传了 SYN,为啥还要传 ACK</a></li><li><a href="#为什么要四次挥手">为什么要四次挥手</a></li></ul></li><li><a href="#5-ip地址与mac地址的区别">5. IP地址与MAC地址的区别</a></li><li><a href="#6-http请求响应报文格式">6. HTTP请求、响应报文格式</a></li><li><a href="#7-为什么要使用索引索引这么多优点为什么不对表中的每一个列创建一个索引呢索引是如何提高查询速度的说一下使用索引的注意事项mysql索引主要使用的两种数据结构什么是覆盖索引">7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?</a></li><li><a href="#8-进程与线程的区别是什么进程间的几种通信方式说一下线程间的几种通信方式知道不">8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？</a></li><li><a href="#9-为什么要用单例模式手写几种线程安全的单例模式">9. 为什么要用单例模式？手写几种线程安全的单例模式？</a></li><li><a href="#10-简单介绍一下bean知道spring的bean的作用域与生命周期吗">10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？</a></li><li><a href="#11-spring-中的事务传播行为了解吗transactiondefinition-接口中哪五个表示隔离级别的常量">11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？</a><ul><li><a href="#事务传播行为">事务传播行为</a></li><li><a href="#隔离级别">隔离级别</a></li></ul></li><li><a href="#12-springmvc-原理了解吗">12. SpringMVC 原理了解吗？</a></li><li><a href="#13-spring-aop-ioc-实现原理">13. Spring AOP IOC 实现原理</a></li></ul><!-- /MarkdownTOC --><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-10/3586727.jpg" alt="备战春招/秋招系列】美团面经总结基础篇 （附详解答案）"></p><p><strong>系列文章：</strong></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484573&amp;idx=1&amp;sn=8c5965d4a3710d405d8e8cc10c7b0ce5&amp;chksm=fd9852fccaefdbea8dfe0bc40188b7579f1cddb1e8905dc981669a3f21d2a04cadceafa9023f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列1】程序员的简历就该这样写</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484592&amp;idx=1&amp;sn=6d9731ce7401be49e97c1af6ed384ecc&amp;chksm=fd9852d1caefdbc720a361ae65a8ad9d53cfb4800b15a7c68cbdc630b313215c6c52e0934ec2&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列3】Java程序员必备书单</a></li></ul><p>这是我总结的美团面经的基础篇，后面还有进阶和终结篇哦！下面只是我从很多份美团面经中总结的在面试中一些常见的问题。不同于个人面经，这份面经具有普适性。每次面试必备的自我介绍、项目介绍这些东西，大家可以自己私下好好思考。我在前面的文章中也提到了应该怎么做自我介绍与项目介绍，详情可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a>。</p><h3 id="1-System-out-println-3-9-输出什么？"><a href="#1-System-out-println-3-9-输出什么？" class="headerlink" title="1.  System.out.println(3 | 9);输出什么？"></a>1.  <code>System.out.println(3 | 9);</code>输出什么？</h3><p>正确答案：11.</p><p><strong>考察知识点：&amp;和&amp;&amp;；|和||</strong></p><p><strong>&amp;和&amp;&amp;：</strong></p><p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是true时，结果为true；</p><p>不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是否为true，是true就继续运算右边的然后判断并输出，是false就停下来直接输出不会再运行后面的东西。</p><p><strong>|和||：</strong></p><p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就为false；</p><p>不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。</p><p><strong>回到本题：</strong></p><p>3 | 9=0011（二进制） | 1001（二进制）=1011（二进制）=11（十进制）</p><h3 id="2-说一下转发-Forward-和重定向-Redirect-的区别"><a href="#2-说一下转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="2. 说一下转发(Forward)和重定向(Redirect)的区别"></a>2. 说一下转发(Forward)和重定向(Redirect)的区别</h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forword）</strong> 通过RequestDispatcher对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说:</strong> forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</li><li><strong>从数据共享来说:</strong> forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</li><li><strong>从运用地方来说:</strong> forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</li><li><strong>从效率来说:</strong> forward:高. redirect:低.</li></ol><h3 id="3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议"><a href="#3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议" class="headerlink" title="3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议"></a>3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</h3><p>图解（图片来源：《图解HTTP》）：</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="状态码"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li></ul><h3 id="4-TCP-三次握手和四次挥手"><a href="#4-TCP-三次握手和四次挥手" class="headerlink" title="4. TCP 三次握手和四次挥手"></a>4. TCP 三次握手和四次挥手</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><p><strong>漫画图解：</strong></p><p>图片来源：《图解HTTP》<br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e127396541f1?w=864&amp;h=439&amp;f=png&amp;s=226095" alt="TCP三次握手"></p><p><strong>简单示意图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e14233d95972?w=542&amp;h=427&amp;f=jpeg&amp;s=15088" alt="TCP三次握手"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方（主动关闭方）到接收方（被动关闭方）的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e1676e2ac0a3?w=500&amp;h=340&amp;f=jpeg&amp;s=13406" alt="TCP四次挥手"></p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h3 id="5-IP地址与MAC地址的区别"><a href="#5-IP地址与MAC地址的区别" class="headerlink" title="5. IP地址与MAC地址的区别"></a>5. IP地址与MAC地址的区别</h3><p>参考：<a href="https://blog.csdn.net/guoweimelon/article/details/50858597" target="_blank" rel="noopener">https://blog.csdn.net/guoweimelon/article/details/50858597</a></p><p>IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。</p><h3 id="6-HTTP请求-响应报文格式"><a href="#6-HTTP请求-响应报文格式" class="headerlink" title="6. HTTP请求,响应报文格式"></a>6. HTTP请求,响应报文格式</h3><p>HTTP请求报文主要由请求行、请求头部、请求正文3部分组成</p><p>HTTP响应报文主要由状态行、响应头部、响应正文3部分组成</p><p>详细内容可以参考：<a href="https://blog.csdn.net/a19881029/article/details/14002273" target="_blank" rel="noopener">https://blog.csdn.net/a19881029/article/details/14002273</a></p><h3 id="7-为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引"><a href="#7-为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引" class="headerlink" title="7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?"></a>7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?</h3><p><strong>为什么要使用索引？</strong></p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快 数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。 </li><li>帮助服务器避免排序和临时表</li><li>将随机IO变为顺序IO</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li></ol><p><strong>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</strong></p><ol><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 </li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 </li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 </li></ol><p><strong>索引是如何提高查询速度的？</strong></p><p>将无序的数据变成相对有序的数据（就像查目录一样）</p><p><strong>说一下使用索引的注意事项</strong></p><ol><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ol><p><strong>Mysql索引主要使用的哪两种数据结构？</strong></p><ul><li>哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li><li>BTree索引：Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</li></ul><p>更多关于索引的内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484486&amp;idx=1&amp;sn=215450f11e042bca8a58eac9f4a97686&amp;chksm=fd985227caefdb3117b8375f150676f5824aa20d1ebfdbcfb93ff06e23e26efbafae6cf6b48e&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【思维导图-索引篇】搞定数据库索引就是这么简单</a></p><p><strong>什么是覆盖索引?</strong></p><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称<br>之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><h3 id="8-进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？"><a href="#8-进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？" class="headerlink" title="8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？"></a>8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？</h3><p> <strong>进程与线程的区别是什么？</strong></p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。</p><p><strong>进程间的几种通信方式说一下？</strong></p><ol><li><strong>管道（pipe）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li><li><strong>信号量（semophore）</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>消息队列（message queue）</strong>：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</li><li><strong>信号（signal）</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li><li><strong>共享内存（shared memory）</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li><li><strong>套接字（socket）</strong>：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。</li></ol><p><strong>线程间的几种通信方式知道不？</strong></p><p>1、锁机制</p><ul><li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li><li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li><li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul><p>2、信号量机制：包括无名线程信号量与有名线程信号量</p><p>3、信号机制：类似于进程间的信号处理。</p><p>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</p><h3 id="9-为什么要用单例模式？手写几种线程安全的单例模式？"><a href="#9-为什么要用单例模式？手写几种线程安全的单例模式？" class="headerlink" title="9. 为什么要用单例模式？手写几种线程安全的单例模式？"></a>9. 为什么要用单例模式？手写几种线程安全的单例模式？</h3><p><strong>简单来说使用单例模式可以带来下面几个好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>懒汉式(双重检查加锁版本)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只有第一次才彻底执行这里的代码</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">               <span class="comment">//进入同步代码块后，再检查一次，如果仍是null，才创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类方式</strong></p><p>静态内部实现的单例是懒加载的且线程安全。</p><p>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？"><a href="#10-简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？" class="headerlink" title="10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？"></a>10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？</h3><p>在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。</p><p>Spring中的bean默认都是单例的，这些单例Bean在多线程程序下如何保证线程安全呢？ 例如对于Web应用来说，Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求，引入Spring框架之后，每个Action都是单例的，那么对于Spring托管的单例Service Bean，如何保证其安全呢？ Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45773d5dd2e?w=563&amp;h=299&amp;f=webp&amp;s=27930" alt="pring的bean的作用域"></p><p>Spring的bean的生命周期以及更多内容可以查看：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484400&amp;idx=2&amp;sn=7201eb365102fce017f89cb3527fb0bc&amp;chksm=fd985591caefdc872a2fac897288119f94c345e4e12150774f960bf5f816b79e4b9b46be3d7f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">一文轻松搞懂Spring中bean的作用域与生命周期</a></p><h3 id="11-Spring-中的事务传播行为了解吗？TransactionDefinition-接口中哪五个表示隔离级别的常量？"><a href="#11-Spring-中的事务传播行为了解吗？TransactionDefinition-接口中哪五个表示隔离级别的常量？" class="headerlink" title="11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？"></a>11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？</h3><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为（为了解决业务层方法之间互相调用的事务问题）：<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p><p><strong>支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>   允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="12-SpringMVC-原理了解吗？"><a href="#12-SpringMVC-原理了解吗？" class="headerlink" title="12. SpringMVC 原理了解吗？"></a>12. SpringMVC 原理了解吗？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45787394192?w=1015&amp;h=466&amp;f=webp&amp;s=35352" alt="SpringMVC 原理"></p><p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Model）-&gt;将得到视图对象返回给用户</p><p>关于 SpringMVC 原理更多内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484496&amp;idx=1&amp;sn=5472ffa687fe4a05f8900d8ee6726de4&amp;chksm=fd985231caefdb27fc75b44ecf76b6f43e4617e0b01b3c040f8b8fab32e51dfa5118eed1d6ad&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">SpringMVC 工作原理详解</a></p><h3 id="13-Spring-AOP-IOC-实现原理"><a href="#13-Spring-AOP-IOC-实现原理" class="headerlink" title="13. Spring AOP IOC 实现原理"></a>13. Spring AOP IOC 实现原理</h3><p>过了秋招挺长一段时间了，说实话我自己也忘了如何简要概括 Spring AOP IOC 实现原理，就在网上找了一个较为简洁的答案，下面分享给各位。</p><p><strong>IOC:</strong> 控制反转也叫依赖注入。IOC利用java反射机制，AOP利用代理模式。IOC 概念看似很抽象，但是很容易理解。说简单点就是将对象交给容器管理，你只需要在spring配置文件中配置对应的bean以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。</p><p><strong>AOP：</strong> 面向切面编程。（Aspect-Oriented Programming） 。AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-systemoutprintln3-|-9输出什么&quot;&gt;1.  &lt;code&gt;System.out.println(3 | 9);&lt;/code&gt;输出什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/books/"/>
    <id>http://yoursite.com/2019/01/17/books/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="核心基础知识"><a href="#核心基础知识" class="headerlink" title="核心基础知识"></a>核心基础知识</h3><ul><li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a>（推荐,豆瓣评分 8.1 , 1.6K+人评价）： 讲漫画一样的讲HTTP，很有意思，不会觉得枯燥，大概也涵盖也HTTP常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究HTTP相关知识的话，读这本书的话应该来说就差不多了。</li><li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a>（推荐，豆瓣评分 7.9 , 1K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</li><li><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">《数据结构与算法分析：C语言描述》</a>（推荐，豆瓣评分 8.9，1.6K+人评价）:本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。</li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>（推荐，豆瓣评分 8.4，0.6K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有算法基础或者说算法没学好的小伙伴用来入门。示例丰富，图文并茂，以让人容易理解的方式阐释了算法.读起来比较快，内容不枯燥！</li><li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：Java语言描述，算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。书的内容非常多，可以说是Java程序员的必备书籍之一了。</li></ul><h3 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h3><ul><li><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">《Effective java 》</a>（推荐，豆瓣评分 9.0，1.4K+人评价）：本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。</li><li><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java.第二版》</a>(推荐，豆瓣评分 8.7，1.0K+人评价)：  可以说是我的Java启蒙书籍了，特别适合新手读当然也适合我们用来温故Java知识点。</li><li><a href="https://book.douban.com/subject/26555197/" target="_blank" rel="noopener">《Java多线程编程核心技术》</a>： Java多线程入门级书籍还不错，但是说实话，质量不是很高，很快就可以阅读完。</li><li><a href="https://book.douban.com/subject/26259017/" target="_blank" rel="noopener">《JAVA网络编程 第4版》</a>：  可以系统的学习一下网络的一些概念以及网络编程在Java中的使用。</li><li><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java核心技术卷1+卷2》</a>（推荐）: 很棒的两本书，建议有点Java基础之后再读，介绍的还是比较深入的，非常推荐。这两本书我一般也会用来巩固知识点，是两本适合放在自己身边的好书。</li><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java编程思想(第4版)》</a>（推荐，豆瓣评分 9.1，3.2K+人评价）：这本书要常读，初学者可以快速概览，中等程序员可以深入看看java，老鸟还可以用之回顾java的体系。这本书之所以厉害，因为它在无形中整合了设计模式，这本书之所以难读，也恰恰在于他对设计模式的整合是无形的。</li><li><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a>（推荐，豆瓣评分 7.2，0.2K+人评价）： 这本书不是很适合作为Java并发入门书籍，需要具备一定的JVM基础。我感觉有些东西讲的还是挺深入的，推荐阅读。</li><li><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a>（推荐）：豆瓣评分 8.3 ，书的质量没的说，推荐大家好好看一下。</li><li><a href="https://book.douban.com/subject/24841235/" target="_blank" rel="noopener">《Java程序员修炼之道》</a>：  很杂，我只看了前面几章，不太推荐阅读。</li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机（第2版）周志明》</a>（推荐，豆瓣评分 8.9，1.0K+人评价）：建议多刷几遍，书中的所有知识点可以通过JAVA运行时区域和JAVA的内存模型与线程两个大模块罗列完全。 </li><li><a href="https://book.douban.com/subject/27038538/" target="_blank" rel="noopener">《Netty实战》</a>（推荐，豆瓣评分 7.8，92人评价）：内容很细，如果想学Netty的话，推荐阅读这本书！</li><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">《从Paxos到Zookeeper》</a>（推荐，豆瓣评分 7.8，0.3K人评价）：简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了Paxos和ZAB协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解ZooKeeper，并更好地使用和运维ZooKeeper。</li></ul><h3 id="JavaWeb相关"><a href="#JavaWeb相关" class="headerlink" title="JavaWeb相关"></a>JavaWeb相关</h3><ul><li><a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">《深入分析Java Web技术内幕》</a>：  感觉还行，涉及的东西也蛮多。</li><li><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring实战（第4版）》</a>（推荐，豆瓣评分 8.3<br>，0.3K+人评价）：不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。这本定位就相当于是关于Spring的新华字典，只有一些基本概念的介绍和示例，涵盖了Spring的各个方面，但都不够深入。就像作者在最后一页写的那样：“学习Spring，这才刚刚开始”。</li><li><a href="https://book.douban.com/subject/4189495/" target="_blank" rel="noopener">《Java Web整合开发王者归来》</a>（已过时）：当时刚开始学的时候就是开的这本书，基本上是完完整整的看完了。不过，我不是很推荐大家看。这本书比较老了，里面很多东西都已经算是过时了。不过，这本书的一个很大优点是：基础知识点概括全面。</li><li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis实战》</a>：如果你想了解Redis的一些概念性知识的话，这本书真的非常不错。</li><li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis设计与实现》</a>（推荐，豆瓣评分 8.5，0.5K+人评价）</li><li><a href="https://book.douban.com/subject/10426640/" target="_blank" rel="noopener">《深入剖析Tomcat》</a>（推荐，豆瓣评分 8.4，0.2K+人评价）：本书深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发Tomcat组件，或者扩展已有的组件。 读完这本书，基本可以摆脱背诵面试题的尴尬。</li><li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能MySQL》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：mysql 领域的经典之作，拥有广泛的影响力。不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。</li><li><a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">深入理解Nginx（第2版）</a>：作者讲的非常细致，注释都写的都很工整，对于 Nginx 的开发人员非常有帮助。优点是细致，缺点是过于细致，到处都是代码片段，缺少一些抽象。</li><li><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">《RabbitMQ实战指南》</a>：《RabbitMQ实战指南》从消息中间件的概念和RabbitMQ的历史切入，主要阐述RabbitMQ的安装、使用、配置、管理、运维、原理、扩展等方面的细节。如果你想浅尝RabbitMQ的使用，这本书是你最好的选择；如果你想深入RabbitMQ的原理，这本书也是你最好的选择；总之，如果你想玩转RabbitMQ，这本书一定是最值得看的书之一</li><li><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud微服务实战》</a>：从时下流行的微服务架构概念出发，详细介绍了Spring Cloud针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li><li><a href="https://book.douban.com/subject/26780404/" target="_blank" rel="noopener">《第一本Docker书》</a>：Docker入门书籍！</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a>（推荐，，豆瓣评分 9.1，0.3K+人评价）：本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。全书分为5个部分：第一部分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口 shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全非常重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。</li></ul><h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3><ul><li><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a>（推荐）:这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java面试通关手册”回复“大型网站技术架构”即可领取思维导图。</li><li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a>（推荐）：一书总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，让读者看后能快速运用到实践项目中。</li><li><a href="https://book.douban.com/subject/27081188/" target="_blank" rel="noopener">《架构解密从分布式到微服务（Leaderus著）》</a>：很一般的书籍，我就是当做课后图书来阅读的。</li></ul><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul><li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a>（推荐）：豆瓣 9.1 分，重构书籍的开山鼻祖。</li></ul><h3 id="课外书籍"><a href="#课外书籍" class="headerlink" title="课外书籍"></a>课外书籍</h3><ul><li>《追风筝的人》（推荐）</li><li>《穆斯林的葬礼》 （推荐）</li><li>《三体》 （推荐）</li><li>《活着——余华》  （推荐）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;核心基础知识&quot;&gt;&lt;a href=&quot;#核心基础知识&quot; class=&quot;headerlink&quot; title=&quot;核心基础知识&quot;&gt;&lt;/a&gt;核心基础知识&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2586351
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2019/01/17/简历模板/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>手机：</li><li>Email：</li><li>微信：</li></ul><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>姓名/性别/出生日期 </li><li>本科/xxx计算机系xxx专业/英语六级</li><li>技术博客：<a href="http://snailclimb.top/" target="_blank" rel="noopener">http://snailclimb.top/</a> </li><li>荣誉奖励：获得了什么奖（获奖时间）</li><li>Github：<a href="https://github.com/Snailclimb" target="_blank" rel="noopener">https://github.com/Snailclimb </a></li><li>Github Resume: <a href="http://resume.github.io/?Snailclimb" target="_blank" rel="noopener">http://resume.github.io/?Snailclimb</a></li><li>期望职位：Java 研发程序员/大数据工程师(Java后台开发为首选)</li><li>期望城市：xxx城市</li></ul><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><h2 id="xxx项目"><a href="#xxx项目" class="headerlink" title="xxx项目"></a>xxx项目</h2><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>介绍该项目是做什么的、使用到了什么技术以及你对项目整体设计的一个感受</p><h3 id="责任描述"><a href="#责任描述" class="headerlink" title="责任描述"></a>责任描述</h3><p>主要可以从下面三点来写：</p><ol><li>在这个项目中你负责了什么、做了什么、担任了什么角色</li><li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li><li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li></ol><h1 id="开源项目和技术文章"><a href="#开源项目和技术文章" class="headerlink" title="开源项目和技术文章"></a>开源项目和技术文章</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li><a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">Java-Guide</a> ：一份涵盖大部分Java程序员所需要掌握的核心知识。Star:3.9K; Fork:0.9k。</li></ul><h2 id="技术文章推荐"><a href="#技术文章推荐" class="headerlink" title="技术文章推荐"></a>技术文章推荐</h2><ul><li><a href="https://juejin.im/post/5b7d69e4e51d4538ca5730cb" target="_blank" rel="noopener">可能是把Java内存区域讲的最清楚的一篇文章</a></li><li><a href="https://juejin.im/post/5b85ea54e51d4538dd08f601" target="_blank" rel="noopener">搞定JVM垃圾回收就是这么简单</a></li><li><a href="https://juejin.im/post/5b3b19856fb9a04fa42f8c71" target="_blank" rel="noopener">前端&amp;后端程序员必备的Linux基础知识</a></li><li><a href="https://juejin.im/post/5b260ec26fb9a00e8e4b031a" target="_blank" rel="noopener">可能是把Docker的概念讲的最清楚的一篇文章</a></li></ul><h1 id="校园经历（可选）"><a href="#校园经历（可选）" class="headerlink" title="校园经历（可选）"></a>校园经历（可选）</h1><h2 id="2016-2017"><a href="#2016-2017" class="headerlink" title="2016-2017"></a>2016-2017</h2><p>担任学校社团-致深社副会长，主要负责团队每周活动的组建以及每周例会的主持。</p><h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p> 担任学校传媒组织：“长江大学在线信息传媒”的副站长以及安卓组成员。主要负责每周例会主持、活动策划以及学校校园通APP的研发工作。</p><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p><ul><li>Web开发：PHP/Hack/Node</li><li>Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li><li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li><li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li><li>数据库相关：MySQL/PgSQL/PDO/SQLite</li><li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li><li>单元测试：PHPUnit/SimpleTest/Qunit</li><li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li></ul><h1 id="自我评价（可选）"><a href="#自我评价（可选）" class="headerlink" title="自我评价（可选）"></a>自我评价（可选）</h1><p>自我发挥。切记不要过度自夸！！！</p><h3 id="感谢您花时间阅读我的简历，期待能有机会和您共事。"><a href="#感谢您花时间阅读我的简历，期待能有机会和您共事。" class="headerlink" title="感谢您花时间阅读我的简历，期待能有机会和您共事。"></a>感谢您花时间阅读我的简历，期待能有机会和您共事。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;联系方式&quot;&gt;&lt;a href=&quot;#联系方式&quot; class=&quot;headerlink&quot; title=&quot;联系方式&quot;&gt;&lt;/a&gt;联系方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;手机：&lt;/li&gt;
&lt;li&gt;Email：&lt;/li&gt;
&lt;li&gt;微信：&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;个人信息
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AE%80%E5%8E%86%E4%B9%8B%E9%81%93/"/>
    <id>http://yoursite.com/2019/01/17/程序员的简历之道/</id>
    <published>2019-01-17T14:37:08.454Z</published>
    <updated>2019-01-14T05:35:11.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员的简历就该这样写"><a href="#程序员的简历就该这样写" class="headerlink" title="程序员的简历就该这样写"></a>程序员的简历就该这样写</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p><font color="red">一份好的简历可以在整个申请面试以及面试过程中起到非常好的作用。</font> 在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。</p><h3 id="2-为什么说简历很重要？"><a href="#2-为什么说简历很重要？" class="headerlink" title="2 为什么说简历很重要？"></a>2 为什么说简历很重要？</h3><h4 id="2-1-先从面试前来说"><a href="#2-1-先从面试前来说" class="headerlink" title="2.1 先从面试前来说"></a>2.1 先从面试前来说</h4><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p><p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p><p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p><p>所以，简历就像是我们的一个门面一样，它在很大程度上决定了你能否进入到下一轮的面试中。</p><h4 id="2-2-再从面试中来说"><a href="#2-2-再从面试中来说" class="headerlink" title="2.2 再从面试中来说"></a>2.2 再从面试中来说</h4><p>我发现大家比较喜欢看面经 ，这点无可厚非，但是大部分面经都没告诉你很多问题都是在特定条件下才问的。举个简单的例子：一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必问的），比如写了你会 redis,那面试官就很大概率会问你 redis 的一些问题。比如：redis的常见数据类型及应用场景、redis是单线程为什么还这么快、 redis 和 memcached 的区别、redis 内存淘汰机制等等。</p><p>所以，首先，你要明确的一点是：<strong>你不会的东西就不要写在简历上</strong>。另外，<strong>你要考虑你该如何才能让你的亮点在简历中凸显出来</strong>，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个项目里使用了什么技术后整体性能和并发量提升了很多等等。</p><p>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。</p><h3 id="3-下面这几点你必须知道"><a href="#3-下面这几点你必须知道" class="headerlink" title="3 下面这几点你必须知道"></a>3 下面这几点你必须知道</h3><ol><li>大部分公司的HR都说我们不看重学历（骗你的！），但是如果你的学校不出众的话，很难在一堆简历中脱颖而出，除非你的简历上有特别的亮点，比如：某某大厂的实习经历、获得了某某大赛的奖等等。</li><li><strong>大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作</strong></li><li><strong>写在简历上的东西一定要慎重，这是面试官大量提问的地方；</strong></li><li><strong>将自己的项目经历完美的展示出来非常重要。</strong></li></ol><h3 id="4-必须了解的两大法则"><a href="#4-必须了解的两大法则" class="headerlink" title="4  必须了解的两大法则"></a>4  必须了解的两大法则</h3><p><strong>①STAR法则（Situation Task Action Result）：</strong></p><ul><li><strong>Situation：</strong> 事情是在什么情况下发生；</li><li><strong>Task:：</strong> 你是如何明确你的任务的；</li><li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li><li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li></ul><p>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p><p>下面这段内容摘自百度百科，我觉得写的非常不错：</p><blockquote><p>STAR法则，500强面试题回答时的技巧法则，备受面试者成功者和500强HR的推崇。<br>由于这个法则被广泛应用于面试问题的回答，尽管我们还在写简历阶段，但是，写简历时能把面试的问题就想好，会使自己更加主动和自信，做到简历，面试关联性，逻辑性强，不至于在一个月后去面试，却把简历里的东西都忘掉了（更何况有些朋友会稍微夸大简历内容）<br>在我们写简历时，每个人都要写上自己的工作经历，活动经历，想必每一个同学，都会起码花上半天甚至更长的时间去搜寻脑海里所有有关的经历，争取找出最好的东西写在简历上。<br>但是此时，我们要注意了，简历上的任何一个信息点都有可能成为日后面试时的重点提问对象，所以说，不能只管写上让自己感觉最牛的经历就完事了，要想到今后，在面试中，你所写的经历万一被面试官问到，你真的能回答得流利，顺畅，且能通过这段经历，证明自己正是适合这个职位的人吗？</p></blockquote><p><strong>②FAB 法则（Feature Advantage Benefit）：</strong></p><ul><li><strong>Feature：</strong> 是什么；</li><li><strong>Advantage：</strong> 比别人好在哪些地方；</li><li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li></ul><p>简单来说，这个法则主要是让你的面试官知道你的优势、招了你之后对公司有什么帮助。</p><h3 id="5-项目经历怎么写？"><a href="#5-项目经历怎么写？" class="headerlink" title="5 项目经历怎么写？"></a>5 项目经历怎么写？</h3><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p><ol><li>对项目整体设计的一个感受</li><li>在这个项目中你负责了什么、做了什么、担任了什么角色</li><li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li><li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li></ol><h3 id="6-专业技能该怎么写？"><a href="#6-专业技能该怎么写？" class="headerlink" title="6 专业技能该怎么写？"></a>6 专业技能该怎么写？</h3><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写(下面这部分内容摘自我的简历，大家可以根据自己的情况做一些修改和完善)：</p><ul><li>计算机网络、数据结构、算法、操作系统等课内基础知识：掌握</li><li>Java 基础知识：掌握</li><li>JVM 虚拟机（Java内存区域、虚拟机垃圾算法、虚拟垃圾收集器、JVM内存管理）：掌握</li><li>高并发、高可用、高性能系统开发：掌握</li><li>Struts2、Spring、Hibernate、Ajax、Mybatis、JQuery ：掌握</li><li>SSH 整合、SSM 整合、 SOA 架构：掌握</li><li>Dubbo： 掌握</li><li>Zookeeper: 掌握</li><li>常见消息队列: 掌握</li><li>Linux：掌握</li><li>MySQL常见优化手段：掌握 </li><li>Spring Boot +Spring Cloud +Docker:了解</li><li>Hadoop 生态相关技术中的 HDFS、Storm、MapReduce、Hive、Hbase ：了解</li><li>Python 基础、一些常见第三方库比如OpenCV、wxpy、wordcloud、matplotlib：熟悉</li></ul><h3 id="7-开源程序员Markdown格式简历模板分享"><a href="#7-开源程序员Markdown格式简历模板分享" class="headerlink" title="7 开源程序员Markdown格式简历模板分享"></a>7 开源程序员Markdown格式简历模板分享</h3><p>分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 。<br>Github地址：<a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a></p><p>我的下面这篇文章讲了如何写一份Markdown格式的简历，另外，文中还提到了一种实现 Markdown 格式到PDF、HTML、JPEG这几种格式的转换方法。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484347&amp;idx=1&amp;sn=a986ea7e199871999a5257bd3ed78be1&amp;chksm=fd9855dacaefdccc2c5d5f8f79c4aa1b608ad5b42936bccaefb99a850a2e6e8e2e910e1b3153&amp;token=719595858&amp;lang=zh_CN#rd" target="_blank" rel="noopener">手把手教你用Markdown写一份高质量的简历</a></p><h3 id="8-其他的一些小tips"><a href="#8-其他的一些小tips" class="headerlink" title="8 其他的一些小tips"></a>8 其他的一些小tips</h3><ol><li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li><li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li><li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li><li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li><li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li><li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li><li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li><li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员的简历就该这样写&quot;&gt;&lt;a href=&quot;#程序员的简历就该这样写&quot; class=&quot;headerlink&quot; title=&quot;程序员的简历就该这样写&quot;&gt;&lt;/a&gt;程序员的简历就该这样写&lt;/h1&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E4%B8%AA%E4%BA%BA%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2019/01/17/个人阅读书籍清单/</id>
    <published>2019-01-17T14:36:36.347Z</published>
    <updated>2019-01-17T13:57:43.725Z</updated>
    
    <content type="html"><![CDATA[<p>下面是个人阅读书籍的部分清单，我比较建议阅读的书籍前都加上了:thumbsup: 表情。</p><blockquote><h3 id="核心基础知识"><a href="#核心基础知识" class="headerlink" title="核心基础知识"></a>核心基础知识</h3></blockquote><ul><li><p>:thumbsup: <a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a></p><p>讲漫画一样的讲HTTP，很有意思，不会觉得枯燥，大概也涵盖也HTTP常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究HTTP相关知识的话，读这本书的话应该来说就差不多了。</p></li></ul><blockquote><h3 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h3></blockquote><ul><li><p>:thumbsup: <a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java.第二版》</a></p><p>可以说是我的Java启蒙书籍了，特别适合新手读当然也适合我们用来温故Java知识点。</p></li><li><p><a href="https://book.douban.com/subject/26555197/" target="_blank" rel="noopener">《Java多线程编程核心技术》</a></p><p>Java多线程入门级书籍还不错，但是说实话，质量不是很高，很快就可以阅读完。</p></li><li><p><a href="https://book.douban.com/subject/26259017/" target="_blank" rel="noopener">《JAVA网络编程 第4版》</a></p><p>可以系统的学习一下网络的一些概念以及网络编程在Java中的使用。</p></li><li><p>:thumbsup: <a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java核心技术卷1+卷2》</a></p><p>很棒的两本书，建议有点Java基础之后再读，介绍的还是比较深入的，非常推荐。这两本书我一般也会用来巩固知识点，是两本适合放在自己身边的好书。</p></li><li><p>:thumbsup: <a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java编程思想(第4版)》</a></p><p>这本书要常读，初学者可以快速概览，中等程序员可以深入看看java，老鸟还可以用之回顾java的体系。这本书之所以厉害，因为它在无形中整合了设计模式，这本书之所以难读，也恰恰在于他对设计模式的整合是无形的。</p></li><li><p>:thumbsup: <a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a></p><p>这本书不是很适合作为Java并发入门书籍，需要具备一定的JVM基础。我感觉有些东西讲的还是挺深入的，推荐阅读。</p></li><li><p>:thumbsup: <a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a></p><p>  豆瓣评分 8.3 ，书的质量没的说，推荐大家好好看一下。</p></li><li><p><a href="https://book.douban.com/subject/24841235/" target="_blank" rel="noopener">《Java程序员修炼之道》</a></p><p>很杂，我只看了前面几章，不太推荐阅读。</p></li><li><p>:thumbsup: <a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机（第2版）周志明》</a></p><p>神书！神书！神书！建议多刷几遍，书中的所有知识点可以通过JAVA运行时区域和JAVA的内存模型与线程两个大模块罗列完全。 </p></li></ul><blockquote><h3 id="JavaWeb相关"><a href="#JavaWeb相关" class="headerlink" title="JavaWeb相关"></a>JavaWeb相关</h3></blockquote><ul><li><p>:thumbsup: <a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">《深入分析Java Web技术内幕》</a></p><p>感觉还行，涉及的东西也蛮多，推荐阅读。</p></li><li><p>:thumbsup: <a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring实战（第4版）》</a></p><p>不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。这本定位就相当于是关于Spring的新华字典，只有一些基本概念的介绍和示例，涵盖了Spring的各个方面，但都不够深入。就像作者在最后一页写的那样：“学习Spring，这才刚刚开始”。</p></li><li><p><a href="https://book.douban.com/subject/4189495/" target="_blank" rel="noopener">《Java Web整合开发王者归来》</a></p><p>当时刚开始学的时候就是开的这本书，基本上是完完整整的看完了。不过，我不是很推荐大家看。这本书比较老了，里面很多东西都已经算是过时了。不过，这本书的一个很大优点是：基础知识点概括全面。</p></li><li><p>:thumbsup: <a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis实战》</a></p><p> 如果你想了解Redis的一些概念性知识的话，这本书真的非常不错。</p></li></ul><blockquote><h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3></blockquote><ul><li><p>:thumbsup: <a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a></p><p>这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java面试通关手册”回复“大型网站技术架构”即可领取思维导图。</p></li><li><p><a href="https://book.douban.com/subject/27081188/" target="_blank" rel="noopener">《架构解密从分布式到微服务（Leaderus著）》</a></p><p>很一般的书籍，我就是当做课后图书来阅读的。</p></li></ul><blockquote><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3></blockquote><ul><li><p>:thumbsup: <a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a></p><p> 豆瓣 9.1 分，重构书籍的开山鼻祖。</p><blockquote><h3 id="linux操作系统相关"><a href="#linux操作系统相关" class="headerlink" title="linux操作系统相关"></a>linux操作系统相关</h3></blockquote></li><li><p>:thumbsup:<a href="https://book.douban.com/subject/25900403/" target="_blank" rel="noopener">&lt;&lt;unix环境编程&gt;&gt;</a> :thumbsup: <a href="https://book.douban.com/subject/1500149/" target="_blank" rel="noopener">&lt;&lt;unix网络编程&gt;&gt;</a></p><p>对于理解linux操作系统原理非常有用，同时可以打好个人的基本功力，面试中很多公司也会问到linux知识。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面是个人阅读书籍的部分清单，我比较建议阅读的书籍前都加上了:thumbsup: 表情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;核心基础知识&quot;&gt;&lt;a href=&quot;#核心基础知识&quot; class=&quot;headerlink&quot; title=&quot;核心基础知识&quot;&gt;&lt;/a&gt;核心基
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/2018%20summary/"/>
    <id>http://yoursite.com/2019/01/17/2018 summary/</id>
    <published>2019-01-17T14:36:36.347Z</published>
    <updated>2019-01-14T05:35:11.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【2018总结】即使平凡，也要热爱自己的生活"><a href="#【2018总结】即使平凡，也要热爱自己的生活" class="headerlink" title="【2018总结】即使平凡，也要热爱自己的生活"></a>【2018总结】即使平凡，也要热爱自己的生活</h1><p>2018 年于我而讲，虽然平凡，但是自己就是在这平凡的一年也收货了很多东西。不光是自己学到的知识，我觉得 2018 年最大的幸运有三:其一是自己拥有了一份爱情，一份甜蜜的初恋，我真的很幸运遇到我现在的女朋友，愿以后的日子都能有她；其一是在 2018 年，我拥有了一份自己还算满意的 offer，马上就要毕业了，自己也要正式进去社会了；其一是自己在 2018 年的实现了自己的经济独立，这是一件让我很高兴的事情，我觉得大在学生时代实现经济独立还算是一件很不错的事情，花了这么多年父母的辛苦钱，自己也终于能替他们分担一点了。2018 年，感恩父母，感恩老师，感恩朋友，感恩遇到的每个善良的人，同时感恩2018年那个还算努力的自己。2019 继续加油！</p><h2 id="一份甜蜜的初恋"><a href="#一份甜蜜的初恋" class="headerlink" title="一份甜蜜的初恋"></a>一份甜蜜的初恋</h2><p>先说说爱情。我和我的女朋友在一起已经半年多了，准确的来说截止到今天也就是 2018-12-30 号已经 190 天了。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-30/54482393.jpg" alt="我和傻欢"></p><p>我俩是异地，我在荆州，她在三亚。相见一面不管是时间上还是经济上对于还是学生的我们来说都甚是不易。见过很多人议论异地恋的种种不好，但是，于我而言，一份好的感情是值得被等待的。“待每一天如初恋，互相尊重彼此生活，共同努力，等老了就退隐山林养老……”，这应该是我和她之间最好的承诺了。</p><h2 id="还算不错的学习收获"><a href="#还算不错的学习收获" class="headerlink" title="还算不错的学习收获"></a>还算不错的学习收获</h2><p>再来说说学习。这一年还算是让人满意，虽然我也不知道这一年自己到底学到了什么。如果你要问我这一年在学习上做的最满意的事情是什么，我还真不好回答，下面就从下面几个维度来简单谈一谈。</p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>这一年自己在Github上还是挺活跃的，提交了很多的代码和文档，同时也收获了很多的star、follower、pr、issue以及fork。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-30/41250517.jpg" alt="我的Github概览"></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-30/33580466.jpg" alt="我的Github贡献概览"></p><p>开源的Java学习/面试指南—JavaGuide 某种程度上让我挺满意的，3月份开源  ，到现在的18k+ star 也算是可以用厚积薄发来形容了。但是，JavaGuide 也有很多让我不满意的，在2019年以及以后我也会继续完善。JavaGuide 地址：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-24/1352784.jpg" alt="JavaGuide 概览"></p><h3 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h3><p>我更新的博客主要都是关于Java方面的，也更新了几篇Python的，有一篇Python的文章竟然在我的CSDN上面阅读霸榜。<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-30/19527688.jpg" alt="霸榜的 Python 文章"></p><p>在这一年，我更新了挺多技术文章，这里就不一一列举了，我贴一下自己觉得不错的文章吧！</p><h4 id="最常见面试题系列"><a href="#最常见面试题系列" class="headerlink" title="最常见面试题系列"></a>最常见面试题系列</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484252&amp;idx=1&amp;sn=cb160d67fc1c0a95babc464b703df5e7&amp;chksm=fd98553dcaefdc2b18f934957dd950aeaf04e90136099fa2817fffbd1e1df452b581e1caee17&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">最最最常见的Java面试题总结——第一周</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484282&amp;idx=1&amp;sn=7f986dc3263b6ca0f9e182145fdd40a1&amp;chksm=fd98551bcaefdc0d5aff9577692881dc79765a339ce97e55958e23e1956aa7092dfac44b68f1&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">最最最常见的Java面试题总结——第二周</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484308&amp;idx=1&amp;sn=e3607919aed604be629617f867f46844&amp;chksm=fd9855f5caefdce3f1ee72cb33b9b3bf9899fa2b64bbb92f1e820c0ef3985245b1f7dfc05358&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这几道Java集合框架面试题在面试中几乎必问</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484337&amp;idx=1&amp;sn=d5e953d4b2da7ed37a7f843bfb437ed8&amp;chksm=fd9855d0caefdcc65cb2e5cc0c69d27f785fc41477bcf55fff2cdff3268b0b078eb1a5107726&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">如果不会这几道多线程基础题，请自觉面壁！</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484355&amp;idx=1&amp;sn=6da29974b6dd1a4aa0d032f44d5fa8de&amp;chksm=fd9855a2caefdcb4c370814baafd4baca27dfccaf609c9edf82370637ba4856176ab143a375e&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">值得立马保存的 synchronized 关键字总结</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484400&amp;idx=1&amp;sn=1b6155015fedfc9f78fabecc18da7b18&amp;chksm=fd985591caefdc870cb018d27f92e1908b6c6e22816a77ead03c4e44b2f53caec00871172b1f&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【面试必备】源码角度一步一步分析 ArrayList 扩容机制</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484539&amp;idx=1&amp;sn=3500cdcd5188bdc253fb19a1bfa805e6&amp;chksm=fd98521acaefdb0c5167247a1fa903a1a53bb4e050b558da574f894f9feda5378ec9d0fa1ac7&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比</a></li></ul><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484188&amp;idx=1&amp;sn=40037de4844f62316465bbe4e910c69c&amp;chksm=fd98557dcaefdc6bedcaeb275aae7c340d46cf6ab0dc96e49c51982f9c53d6a44de283efc9a8&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">近几个月Github上最热门的Java项目一览</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484333&amp;idx=1&amp;sn=8c97b029692877a537d55175a8c82977&amp;chksm=fd9855cccaefdcdaffe0558ba5e8dca415495935b0ad1181e6b148b08e1c86ce5d841e9df901&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">推荐10个Java方向最热门的开源项目（8月）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484644&amp;idx=1&amp;sn=5016caaf97e498b76de2189e3f55e9dc&amp;chksm=fd985285caefdb93f4e3c7545d30edac6ad31b99f1fcc4503350101f0b20bba9a9705ed7d124&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Github上 Star 数相加超过 7w+ 的三个面试相关的仓库推荐</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484730&amp;idx=1&amp;sn=86e35dfea1478221b6d14a263e88ac89&amp;chksm=fd98535bcaefda4d4f03bf0cd2e0a8fd9f44b1a2b118457a0c8b3de2ff8a1f4c4b7cd083f40e&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">11月 Github Trending 榜最热门的 10 个 Java 项目</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484817&amp;idx=1&amp;sn=12f0c254a240c40c2ccab8314653216b&amp;chksm=fd9853f0caefdae6d191e6bf085d44ab9c73f165e3323aa0362d830e420ccbfad93aa5901021&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">盘点一下Github上开源的Java面试/学习相关的仓库，看完弄懂薪资至少增加10k</a></li></ul><h4 id="备战面试系列"><a href="#备战面试系列" class="headerlink" title="备战面试系列"></a>备战面试系列</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484529&amp;idx=1&amp;sn=9c7a3d6ad124affcadc19b0ff49bf68a&amp;chksm=fd985210caefdb0615a9643fa698cb6267e89562730423841d942cde17ec9c1280dfc3a2b933&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">可能是一份最适合你的后端面试指南（部分内容前端同样适用）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484573&amp;idx=1&amp;sn=8c5965d4a3710d405d8e8cc10c7b0ce5&amp;chksm=fd9852fccaefdbea8dfe0bc40188b7579f1cddb1e8905dc981669a3f21d2a04cadceafa9023f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列1】程序员的简历就该这样写</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484592&amp;idx=1&amp;sn=6d9731ce7401be49e97c1af6ed384ecc&amp;chksm=fd9852d1caefdbc720a361ae65a8ad9d53cfb4800b15a7c68cbdc630b313215c6c52e0934ec2&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列3】Java程序员必备书单</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484601&amp;idx=1&amp;sn=4907b7fef0856791c565d49d788ba8cc&amp;chksm=fd9852d8caefdbce88e51c0a10a4ec77c97f382fd2af4a840ea47cffc828bfd0f993f50d5f0d&amp;token=1895808268&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列】美团面经总结基础篇 （附详解答案）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484625&amp;idx=1&amp;sn=9c4fa1f7d4291a5fbd7daa44bac2b012&amp;chksm=fd9852b0caefdba6edcf9a827aa4a17ddc97bf6ad2e5ee6f7e1aa1b443b54444d05d2b76732b&amp;token=1895808268&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列】美团面经总结进阶篇 （附详解答案）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484668&amp;idx=1&amp;sn=9d4631588393075d9c453f307410f0cd&amp;chksm=fd98529dcaefdb8b5497d1f161834af6917c33ea3d305eb41872e522707fa94218769ca60101&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列】美团Java面经总结终结篇 （附详解答案）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484739&amp;idx=1&amp;sn=25cf5b36090f69299150663bdccfeec2&amp;chksm=fd985322caefda34df0734efa607114704d1937f083aee2230b797d1f5aa04f7d13bf2f81dc5&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">GitHub 上四万 Star 大佬的求职回忆</a>(非原创)</li></ul><h4 id="并发编程面试必备"><a href="#并发编程面试必备" class="headerlink" title="并发编程面试必备"></a>并发编程面试必备</h4><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484539&amp;idx=1&amp;sn=3500cdcd5188bdc253fb19a1bfa805e6&amp;chksm=fd98521acaefdb0c5167247a1fa903a1a53bb4e050b558da574f894f9feda5378ec9d0fa1ac7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">并发编程面试必备：synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484553&amp;idx=1&amp;sn=aca9fa19f723206eff7e33a10973a887&amp;chksm=fd9852e8caefdbfe7180c34f83bbb422a1a0bef1ed44b1e84f56924244ea3fd2da720f25c6dd#rd" target="_blank" rel="noopener">并发编程面试必备：JUC 中的 Atomic 原子类总结</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484559&amp;idx=1&amp;sn=28dae85c38c4c500201c39234d25d731&amp;chksm=fd9852eecaefdbf80cc54a25204e7c7d81170ce659acf92b7fa4151799ca3d0d7df2225d4ff1#rd" target="_blank" rel="noopener">并发编程面试必备：AQS 原理以及 AQS 同步组件总结</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484564&amp;idx=1&amp;sn=d8467fdc5c1b3883e9b99485f7b0fb9a&amp;chksm=fd9852f5caefdbe364d1c438865cff84acd8f40c1c9e2f9f5c8fef673b30f905b4c5f5255368&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">并发编程面试必备：BATJ都爱问的多线程面试题</a></li></ul><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484303&amp;idx=1&amp;sn=af0fd436cef755463f59ee4dd0720cbd&amp;chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">可能是把Java内存区域讲的最清楚的一篇文章</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484328&amp;idx=1&amp;sn=214f5e18a6afa096eb552fd8627e0cea&amp;chksm=fd9855c9caefdcdf70c746c74d31f65bbb109eedaea0cfe311a1e10af666047df59ff04c873b&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">搞定 JVM 垃圾回收就是这么简单</a></li></ul><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484706&amp;idx=1&amp;sn=d413fc17023482f67ca17cb6756b9ff8&amp;chksm=fd985343caefda555969568fdf4734536e0a1745f9de337d434a7dbd04e893bd2d75f3641aab&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">超详细，新手都能看懂 ！使用SpringBoot+Dubbo 搭建一个简单的分布式服务</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484730&amp;idx=2&amp;sn=9be4636dd9a416b46f9029df68fad232&amp;chksm=fd98535bcaefda4dccf14a286a24fcd2b3d4ab0d0e4d89dfbc955df99d2b06a1e17392b3c10b&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">基于 SpringBoot2.0+优雅整合 SpringBoot+Mybatis</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484737&amp;idx=1&amp;sn=e39693d845f022d689437ee58948ef6a&amp;chksm=fd985320caefda36d5ab8abd52f5516c11cc5d1104608695bcea5909602b28dc40c132d6d46c&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">新手也能实现，基于SpirngBoot2.0+ 的 SpringBoot+Mybatis 多数据源配置</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484745&amp;idx=1&amp;sn=dbeec694916d204605929244d48a6b1c&amp;chksm=fd985328caefda3e793170d81433c7c0b7dc1c4a4ae99395cce23b1d1a239482fd5bf1d89bc6&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">SpringBoot 整合 阿里云OSS 存储服务，快来免费搭建一个自己的图床</a></li></ul><h4 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484516&amp;idx=1&amp;sn=4e2320613e76dd73a130c63beebbc3ca&amp;chksm=fd985205caefdb13b4b611ed3c604d95314d28d567ec0c3b44585b89a7dc3142bcd52bc2d4cb&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">结束了我短暂的秋招，说点自己的感受</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484477&amp;idx=1&amp;sn=3b597e2431611aacca2b5d671a309d85&amp;chksm=fd98525ccaefdb4a7e3742b5958244d453efe26f61f42f9f108190a0c18313f083189f10944e&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">保研之路：从双非到南大</a>(非原创)</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484650&amp;idx=1&amp;sn=e97ea1eeebdb5def58bae1949bec9448&amp;chksm=fd98528bcaefdb9d76ac62fd10544f058b1fee4a40ffd06ab9312b7eb3a62f86d67ea653b88a&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【周日闲谈】最近想说的几件小事</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484836&amp;idx=1&amp;sn=a6ada99c9506af01dc3bb472f66c57be&amp;chksm=fd9853c5caefdad3034dbed00cf04412ea990fc05b6168720e6828ae6c90c9a885793acd7a14&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">这7个问题，可能大部分Java程序员都比较关心吧！</a></li></ul><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484127&amp;idx=1&amp;sn=70ee95619ec761da884c4f9af3e83194&amp;chksm=fd9854becaefdda81a02bf6cf9bd07a2fc879efa7cefc79691a0d319b501d8572e8bad981d87&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">可能是把Docker的概念讲的最清楚的一篇文章</a></li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484157&amp;idx=1&amp;sn=8b47e623e83fb3666bce7c680e4649b8&amp;chksm=fd98549ccaefdd8ad815f3d8eaca86cc7e7245b4f8de1d23897af3017f5fdb3f152734c40f5e&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">后端程序员必备的Linux基础知识</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484696&amp;idx=1&amp;sn=d3c1ba5abc10c10ff844cae2109a2628&amp;chksm=fd985379caefda6faff8e050b7dfa1e92fbfe2912e44150cb4ae349aea807836166355062970&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">快速入门大厂后端面试必备的 Shell 编程</a></li></ul><h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484379&amp;idx=1&amp;sn=036f5d3defa8a6979afb77acc82a9517&amp;chksm=fd9855bacaefdcacc1462f781b634e5599f2ee9e806bd24297dae4af0e4196a70ca6bbd8c354&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">可能是全网把 ZooKeeper 概念讲的最清楚的一篇文章</a></li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484450&amp;idx=1&amp;sn=7ee03fa67aecd05c5becd2a8259d3631&amp;chksm=fd985243caefdb554ebab9149e750ac0c819074c57bd208f2d7f097fbc461ed58223e71c05f1&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">redis 总结——重构版</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484478&amp;idx=1&amp;sn=a1250d9b8025cd7cb6fc6a58238ab51e&amp;chksm=fd98525fcaefdb499a027df0138c98d4b02d828f27bd6144a4d40a1c088d340c29dd53d4a026&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">史上最全Redis高可用技术解决方案大全</a>(非原创)</li></ul><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484289&amp;idx=1&amp;sn=6b556843c60aac9a17b0e7c2e3cd6bca&amp;chksm=fd9855e0caefdcf6af4123b719448c81d90c5442d4052ae01a4698047e226c0c18c14b2cc54a&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">搞定计算机网络面试，看这篇就够了（补充版）</a></li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484486&amp;idx=1&amp;sn=215450f11e042bca8a58eac9f4a97686&amp;chksm=fd985227caefdb3117b8375f150676f5824aa20d1ebfdbcfb93ff06e23e26efbafae6cf6b48e&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【思维导图-索引篇】搞定数据库索引就是这么简单</a></li></ul><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484789&amp;idx=1&amp;sn=ba972f0aac39e9a28b29ddf92fc15c18&amp;chksm=fd985314caefda0278235427d43846b6374ff32f4149352dec063287cbf9733b888acbb79923&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">新手也能看懂，消息队列其实很简单</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484796&amp;idx=1&amp;sn=bc56fecb634732669cfe7db8d1820ded&amp;chksm=fd98531dcaefda0b07b8a9c13429ef225d36a6e287c96c53d7aa3dfd65c62ccd60d13b22ebbf&amp;token=1398134989&amp;lang=zh_CN#rd" target="_blank" rel="noopener">一文搞懂 RabbitMQ 的重要概念以及安装</a></li></ul><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>推荐一下 2018 年看过的书籍，小部分可能2017年也看过一些。</p><h4 id="已看完"><a href="#已看完" class="headerlink" title="已看完"></a>已看完</h4><ul><li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a>（推荐,豆瓣评分 8.1 , 1.6K+人评价）： 讲漫画一样的讲HTTP，很有意思，不会觉得枯燥，大概也涵盖也HTTP常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究HTTP相关知识的话，读这本书的话应该来说就差不多了。</li><li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a>（推荐，豆瓣评分 7.9 , 1K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>（推荐，豆瓣评分 8.4，0.6K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有算法基础或者说算法没学好的小伙伴用来入门。示例丰富，图文并茂，以让人容易理解的方式阐释了算法.读起来比较快，内容不枯燥！</li><li><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a>（推荐，豆瓣评分 7.2，0.2K+人评价）： 这本书不是很适合作为Java并发入门书籍，需要具备一定的JVM基础。我感觉有些东西讲的还是挺深入的，推荐阅读。</li><li><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a>（推荐）：豆瓣评分 8.3 ，书的质量没的说，推荐大家好好看一下。</li><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机（第2版）周志明》</a>（推荐，豆瓣评分 8.9，1.0K+人评价）：建议多刷几遍，书中的所有知识点可以通过JAVA运行时区域和JAVA的内存模型与线程两个大模块罗列完全。 </li><li><a href="https://book.douban.com/subject/27038538/" target="_blank" rel="noopener">《Netty实战》</a>（推荐，豆瓣评分 7.8，92人评价）：内容很细，如果想学Netty的话，推荐阅读这本书！</li><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">《从Paxos到Zookeeper》</a>（推荐，豆瓣评分 7.8，0.3K人评价）：简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了Paxos和ZAB协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解ZooKeeper，并更好地使用和运维ZooKeeper。</li><li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis实战》</a>：如果你想了解Redis的一些概念性知识的话，这本书真的非常不错。</li><li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis设计与实现》</a>（推荐，豆瓣评分 8.5，0.5K+人评价）</li><li><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a>（推荐）:这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java面试通关手册”回复“大型网站技术架构”即可领取思维导图。</li></ul><h4 id="未看完"><a href="#未看完" class="headerlink" title="未看完"></a>未看完</h4><ul><li><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a>（推荐，，豆瓣评分 9.1，0.3K+人评价）：本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。全书分为5个部分：第一部分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口 shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全非常重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。</li><li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a>（推荐）：一书总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，让读者看后能快速运用到实践项目中。</li><li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a>（推荐）：豆瓣 9.1 分，重构书籍的开山鼻祖。</li><li><a href="https://book.douban.com/subject/10426640/" target="_blank" rel="noopener">《深入剖析Tomcat》</a>（推荐，豆瓣评分 8.4，0.2K+人评价）：本书深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发Tomcat组件，或者扩展已有的组件。 读完这本书，基本可以摆脱背诵面试题的尴尬。</li><li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能MySQL》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：mysql 领域的经典之作，拥有广泛的影响力。不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。</li><li><a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">深入理解Nginx（第2版）</a>：作者讲的非常细致，注释都写的都很工整，对于 Nginx 的开发人员非常有帮助。优点是细致，缺点是过于细致，到处都是代码片段，缺少一些抽象。</li><li><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">《RabbitMQ实战指南》</a>：《RabbitMQ实战指南》从消息中间件的概念和RabbitMQ的历史切入，主要阐述RabbitMQ的安装、使用、配置、管理、运维、原理、扩展等方面的细节。如果你想浅尝RabbitMQ的使用，这本书是你最好的选择；如果你想深入RabbitMQ的原理，这本书也是你最好的选择；总之，如果你想玩转RabbitMQ，这本书一定是最值得看的书之一</li><li><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud微服务实战》</a>：从时下流行的微服务架构概念出发，详细介绍了Spring Cloud针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li><li><a href="https://book.douban.com/subject/26780404/" target="_blank" rel="noopener">《第一本Docker书》</a>：Docker入门书籍！</li><li><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">《Effective java 》</a>（推荐，豆瓣评分 9.0，1.4K+人评价）：本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。</li><li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：Java语言描述，算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。书的内容非常多，可以说是Java程序员的必备书籍之一了。</li></ul><h2 id="一些个人愚见"><a href="#一些个人愚见" class="headerlink" title="一些个人愚见"></a>一些个人愚见</h2><h3 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h3><p>不知道大家收藏栏是不是和我一样收藏了很多文章，但是有多少篇是你真真认真看的呢？或者那几篇你认真看之后，经过一个月之后还记得这篇文章的大概内容。现在这个社会真是一个信息爆炸的社会，我个人真的深有感触，就在刚刚我还取消关注了好多微信公众号，很多公众号给我推的文章都有好几十篇了，但是我一篇都没有看，所以索性取消关注，省个位置。我个人觉得遇到好的文章，我们不光要读，而且要记录下来。就拿我本人来说，我平时喜欢用 OneNote 来记录学习笔记以及其他我感觉重要的事情比如重要人的生日啦这些。每当遇到自己喜欢的文章的时候，我都先会把文章的地址保存到我分好类的笔记本上，我会先进行第一遍阅读，第一遍我会读的很仔细，如果晦涩难懂的话我会先快速把总体看一遍，然后在细细品读。一般第二遍的时候我就会在笔记本上记录这篇文章的一些要点，以便我日后看到这些要点可以快速回忆起整篇文章的内容。如果某篇文章的知识点太过庞大的话，我会去选择采用思维导图的方式展示要点。看视频一样，看教学视频的话，如果觉得老师讲的不错，我们不妨记录下来，Onenote 或者有道云笔记都行，记录大概，够我们日后回忆就好。</p><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><p>做事不要有功利性，我最早在掘金写文章，其实也只是为了记录自己的学习，没想到会有人喜欢自己的文章，另外我课外学的很多东西，我自己也不清楚以后工作会不会用到，反正我自己感觉即然自己感兴趣，那么就去学吧。我相信，很多东西可能暂时带给你不了带多实质性的帮助，但是总有一天它会对你有帮助。如果感到迷茫的话，就做好眼前的事（拿我们班主任的话说，如果你感到迷茫，你就学好现在的专业知识就好了），我觉得没毛病。</p><h3 id="关于个人"><a href="#关于个人" class="headerlink" title="关于个人"></a>关于个人</h3><p>在生活中一定要保持谦虚，保持谦虚，保持谦虚，时刻都要有反省的准备，你要记住学无止境，永远不要满足现在的现状。另外，就是一定要掌控好自己的时间，多留点时间给父母亲人，以及那些自己在乎的人。如果对别人很在乎的话，不要去装作不在乎，因为这样真的不是太好，虽然我之前也会这样，很多时候撰写的消息，最后没发出去。</p><h2 id="最后分享一句话"><a href="#最后分享一句话" class="headerlink" title="最后分享一句话"></a>最后分享一句话</h2><p>分享给大家,我笔记本里一直保存的杨绛老先生的一句话：“我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系！”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【2018总结】即使平凡，也要热爱自己的生活&quot;&gt;&lt;a href=&quot;#【2018总结】即使平凡，也要热爱自己的生活&quot; class=&quot;headerlink&quot; title=&quot;【2018总结】即使平凡，也要热爱自己的生活&quot;&gt;&lt;/a&gt;【2018总结】即使平凡，也要热爱自己的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91%E9%83%BD%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/01/17/选择技术方向都要考虑哪些因素/</id>
    <published>2019-01-17T14:36:36.347Z</published>
    <updated>2019-01-14T05:35:11.614Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是作者读安晓辉老师的《程序员程序员职场进阶 32 讲 》中关于“选择技术方向都要考虑哪些因素”这部分做的一些笔记和自己的思考。在这里分享给各位！</p><h3 id="选择一种技术可能会考虑到的决定因素"><a href="#选择一种技术可能会考虑到的决定因素" class="headerlink" title="选择一种技术可能会考虑到的决定因素"></a>选择一种技术可能会考虑到的决定因素</h3><ol><li><p>就业机会</p><p>选择一门就业面广的技术还是比较重要的。我的很多学PHP的同学现在都在培训班学Java，真的！！！</p></li><li><p>难易程度</p><p> 我当时是在C/C++语言与Java中选择了Java，因为我感觉Java学起来确实要比C++简单一些。</p></li><li><p>个人兴趣</p><p>兴趣是你能坚持下来的一个很重要的条件。</p></li><li><p>薪资水平</p><p>薪资虽然不是人的唯一追求，但是一定是必备的追求。</p></li><li><p>发展前景</p><p>你肯定不愿意看到这种情况发生：选择了一门技术，结果一年后它就没人用、没市场了。所以我们在选择时就要考虑这一点，做一些预判。</p><p>选择技术时存在两种考虑：一种是选择稳定的、经典的技术；一种是卡位将来的市场缺口，选择将来可能需要用到的技术。</p></li><li><p>他人推荐</p><p>我们在懵懵懂懂的时候，往往最容易听从别人的推荐，然后选择某种技术。</p></li><li><p>相近原则</p><p>当我们已经掌握了一些技术，要学习新技术时，就可以根据一种新技术是否和自己已经掌握的技术比较接近来判断选择。相近的技术，学起来会更容易上手。</p></li><li><p>互补原则</p><p>和相近性类似，互补性也常用在拓展我们技术能力的情景下。它指的是，有一些技术可以和你已经掌握的技术互相补充，组合在一起，形成更完整、更系统的技术图谱，给你带来更大的竞争力。关于相近原则与互补原则，我们也会在后面的文章里具体解读。</p></li><li><p>团队技术图谱</p><p>我觉得这个可能就是团队开发过程中的需要。比如在做一个项目的时候，这个项目需要你去学习一下某个你没有接触过的新技术。</p></li></ol><h3 id="入行时如何选择技术方向"><a href="#入行时如何选择技术方向" class="headerlink" title="入行时如何选择技术方向"></a>入行时如何选择技术方向</h3><p> 为了明确自己的求职目标，可以问问自己下面的问题：</p><ul><li>我想在哪个城市工作？</li><li>我想在哪些行业、领域发展？</li><li>我想去什么样的公司？</li><li>我想做什么样的产品？   </li></ul><p>另外你要知道的是热门技术会有更多机会，相应竞争压力也会更大，并不能保证你找到合适的工作。<br>冷门技术，机会相对较少，而且机会相对确定 。</p><h3 id="构建技能树时如何选择技术方向"><a href="#构建技能树时如何选择技术方向" class="headerlink" title="构建技能树时如何选择技术方向"></a>构建技能树时如何选择技术方向</h3><p>当我们过了专项能力提升的初级阶段之后，就应该开始构建自己的技能体系了。在为搭建技能树而选择技术时，通常考虑下面两个原则：</p><ul><li>相近原则</li><li>互补原则</li></ul><p>“学习技术时一定要学对自己以后发展有用的技术”是我经常对自己强调的，另外我觉得很误导人同时也很错误的一个思想是：“只要是技术学了就会有用的”，这句话在我刚学编程时经常听到有人对我说。希望大家不要被误导，很多技术过时了就是过时了，没有必要再去花时间学。</p><p>我觉得相近原则和互补原则互补原则就是你主精和自己技术方向相同的的东西或者对自己技术领域有提升的东西。比如我目前暂时选择了Java为我的主要发展语言，所以我就要求自己大部分时间还是搞和Java相关的东西比如：Spring、SpingBoot、Dubbo、Mybatis等等。但是千万不要被语言所束缚，在业余时间我学的比较多的就是Python以及JS、C/C++/C#也会偶尔接触。因为我经常会接触前端另外我自己偶尔有爬虫需求或者需要用Python的一些第三库解决一些问题，所以我业余学Pyton以及JS就比较多一点，我觉得这两门技术也是对我现有技术的一个补充了。</p><h3 id="技术转型时的方向选择"><a href="#技术转型时的方向选择" class="headerlink" title="技术转型时的方向选择"></a>技术转型时的方向选择</h3><p>我觉得对于技术转型主要有一下几点建议</p><ul><li>与自己当前技术栈跨度不太大的领域，比如你做安卓的话转型可以选择做Java后端。</li><li>真正适合自己去做的，并不是一味看着这个领域火了（比如人工智能），然后自己就不考虑实际的去转型到这个领域里去。</li><li>技术转型方向尽量对自己以后的发展需要有帮助。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要是作者读安晓辉老师的《程序员程序员职场进阶 32 讲 》中关于“选择技术方向都要考虑哪些因素”这部分做的一些笔记和自己的思考。在这里分享给各位！&lt;/p&gt;
&lt;h3 id=&quot;选择一种技术可能会考虑到的决定因素&quot;&gt;&lt;a href=&quot;#选择一种技术可能会考虑到的决定因素&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/2018%20%E7%A7%8B%E6%8B%9B/"/>
    <id>http://yoursite.com/2019/01/17/2018 秋招/</id>
    <published>2019-01-17T14:36:36.347Z</published>
    <updated>2019-01-14T05:35:11.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秋招历程流水账总结"><a href="#秋招历程流水账总结" class="headerlink" title="秋招历程流水账总结"></a>秋招历程流水账总结</h1><p>笔主大四准毕业生，在秋招末流比较幸运地进入了一家自己非常喜欢一家公司——ThoughtWorks.</p><p><img src="https://images.gitbook.cn/1433af10-d5f7-11e8-841a-4f0b0cc7be7b" alt="今天去签约在门外拍的照片"></p><p>从9-6号投递出去第一份简历，到10-18号左右拿到第一份 offer ，中间差不多有 1 个半月的时间了。可能自己比较随缘，而且自己所在的大学所处的位置并不是互联网比较发达的城市的原因。所以，很少会有公司愿意跑到我们学校那边来宣讲，来的公司也大多是一些自己没听过或者不太喜欢的公司。所以，在前期，我仅仅能够通过网上投递简历的方式来找工作。</p><p>零零总总算了一下，自己在网上投了大概有 10 份左右的简历，都是些自己还算喜欢的公司。简单说一下自己投递的一些公司：网上投递的公司有：ThoughtWorks、网易、小米、携程、爱奇艺、知乎、小红书、搜狐、欢聚时代、京东；直接邮箱投递的有：烽火、中电数据、蚂蚁金服花呗部门、今日头条；线下宣讲会投递的有：玄武科技。</p><p>网上投递的大部分简历都是在做完笔试之后就没有了下文了，即使有几场笔试自我感觉做的很不错的情况下，还是没有收到后续的面试邀请。还有些邮箱投递的简历，后面也都没了回应。所以，我总共也只参加了3个公司的面试，ThoughtWorks、玄武科技和中电数据，都算是拿到了 offer。拿到 ThoughtWorks 的 offer之后，后面的一些笔试和少部分面试都拒了。决定去 ThoughtWorks 了，春招的大部队会没有我的存在。</p><p>我个人对 ThoughtWorks 最有好感，ThoughtWorks 也是我自己之前很想去的一家公司。不光是因为我投递简历的时候可以不用重新填一遍表格可以直接发送我已经编辑好的PDF格式简历的友好，这个公司的文化也让我很喜欢。每次投递一家公司几乎都要重新填写一遍简历真的很让人头疼，即使是用牛客网的简历助手也还是有很多东西需要自己重新填写。</p><p>说句实话，自己在拿到第一份 offer 之前心里还是比较空的，虽然说对自己还是比较自信。包括自己当时来到武汉的原因，也是因为自己没有 offer ，就感觉心里空空的，我相信很多人在这个时候与我也有一样的感觉。然后，我就想到武汉参加一下别的学校宣讲会。现在看来，这个决定也是不必要的，因为我最后去的公司 ThoughtWorks，虽然就在我租的房子的附近，但之前投递的时候，选择的还是远程面试。来到武汉，简单的修整了一下之后，我就去参加了玄武科技在武理工的宣讲会，顺便做了笔试，然后接着就是技术面、HR面、高管面。总体来说，玄武科技的 HR 真的很热情，为他们点个赞，虽然自己最后没能去玄武科技，然后就是技术面非常简单，HR面和高管面也都还好，不会有压抑的感觉，总体聊得很愉快。需要注意的是 玄武科技和很多公司一样都有笔试中有逻辑题，我之前没有做过类似的题，所以当时第一次做有点懵逼。高管面的时候，高管还专门在我做的逻辑题上聊了一会，让我重新做了一些做错的题，并且给他讲一些题的思路，可以看出高层对于应聘者的这项能力还是比较看重的。</p><p>中电数据的技术面试是电话进行的，花了1个多小时一点，个人感觉问的还是比较深的，感觉自己总体回答的还是比较不错的。</p><p>这里我着重说一下 ThoughtWorks，也算是给想去 ThoughtWorks 的同学一点小小的提示。我是 9.11 号在官网：<a href="https://join.thoughtworks.cn/" target="_blank" rel="noopener">https://join.thoughtworks.cn/</a> 投递的简历，9.20 日邮件通知官网下载作业，作业总体来说不难，9.21 号花了半天多的时间做完，然后就直接在9.21 号下午提交了。然后等了挺长时间的，可能是因为 ThoughtWorks 在管理方面比较扁平化的原因，所以总体来说效率可能不算高。因为我选的是远程面试，所以直接下载好 zoom 之后，等HR打电话过来告诉你一个房间号，你就可以直接进去面试就好，一般技术面试有几个人看着你。技术面试的内容，首先就是在面试官让你在你之前做的作业的基础上新增加一个或者两个功能（20分钟）。所以，你在技术面试之前一定要保证你的程序的扩展性是不错的，另外就是你在技术面试之前最好能重构一下自己写的程序。重构本身就是你自己对你写的程序的理解加强很好的一种方式，另外重构也能让你发现你的程序的一些小问题。然后，这一步完成之后，面试官可能会问你一些基础问题，比较简单，所以我觉得 ThoughtWorks 可能更看重你的代码质量。ThoughtWorks 的 HR 面和其他公司的唯一不同可能在于，他会让你用英语介绍一下自己或者说自己的技术栈啊这些。</p><p><img src="https://images.gitbook.cn/83f765e0-d5f6-11e8-9c1a-919e09988420" alt="思特沃克可爱的招聘官网"></p><h1 id="关于面试一些重要的问题总结"><a href="#关于面试一些重要的问题总结" class="headerlink" title="关于面试一些重要的问题总结"></a>关于面试一些重要的问题总结</h1><p>另外，再给大家总结一些我个人想到一些关于面试非常重要的一些问题。</p><h3 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h3><p><strong>如何准备</strong></p><p>运筹帷幄之后，决胜千里之外！不打毫无准备的仗，我觉得大家可以先从下面几个方面来准备面试：</p><ol><li>自我介绍。（你可千万这样介绍：“我叫某某，性别，来自哪里，学校是那个，自己爱干什么”，记住：多说点简历上没有的，多说点自己哪里比别人强！）</li><li>自己面试中可能涉及哪些知识点、那些知识点是重点。</li><li>面试中哪些问题会被经常问到、面试中自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li><li>自己的简历该如何写。</li></ol><p>另外，如果你想去类似阿里巴巴、腾讯这种比较大的互联网公司的话，一定要尽早做打算。像阿里巴巴在7月份左右就开始了提前批招聘，到了9月份差不多就已经招聘完毕了。所以，秋招没有参加到阿里的面试还是很遗憾的，毕竟面试即使失败了，也能从阿里难度Max的面试中学到很多东西。</p><p><strong>关于着装</strong></p><p>穿西装、打领带、小皮鞋？NO！NO！NO！这是互联网公司面试又不是去走红毯，所以你只需要穿的简单大方就好，不需要太正式。</p><p><strong>关于自我介绍</strong></p><p>如果你简历上写的基本信息就不要说了，比如性别、年龄、学校。另外，你也不要一上来就说自己爱好什么这方面内容。因为，面试官根本不关心这些东西。你直接挑和你岗位相关的重要经历和自己最突出的特点讲就好了。</p><p><strong>提前准备</strong></p><p>面试之前可以在网上找找有没有你要面试的公司的面经。在我面试 ThoughtWorks 的前几天我就在网上找了一些关于 ThoughtWorks 的技术面的一些文章。然后知道了 ThoughtWorks 的技术面会让我们在之前做的作业的基础上增加一个或两个功能，所以我提前一天就把我之前做的程序重新重构了一下。然后在技术面的时候，简单的改了几行代码之后写个测试就完事了。如果没有提前准备，我觉得 20 分钟我很大几率会完不成这项任务。</p><h3 id="面试中"><a href="#面试中" class="headerlink" title="面试中"></a>面试中</h3><p>面试的时候一定要自信，千万不要怕自己哪里会答不出来，或者说某个问题自己忘记怎么回答了。面试过程中，很多问题可能是你之前没有碰到过的，这个时候你就要通过自己构建的知识体系来思考这些问题。如果某些问题你回答不上来，你也可以让面试官给你简单的提示一下。总之，你要自信，你自信的前提是自己要做好充分的准备。下面给大家总结一些面试非常常见的问题：</p><ul><li>SpringMVC 工作原理</li><li>说一下自己对 IOC 、AOP 的理解</li><li>Spring 中用到了那些设计模式，讲一下自己对于这些设计模式的理解</li><li>Spring Bean 的作用域和生命周期了解吗</li><li>Spring 事务中的隔离级别</li><li>Spring 事务中的事务传播行为</li><li>手写一个 LRU 算法</li><li>知道那些排序算法，简单介绍一下快排的原理，能不能手写一下快排</li><li>String 为什么是不可变的？String为啥要设计为不可变的？</li><li>Arraylist 与 LinkedList 异同</li><li>HashMap的底层实现</li><li>HashMap 的长度为什么是2的幂次方</li><li>ConcurrentHashMap 和 Hashtable 的区别</li><li>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</li><li>如果你的简历写了redis 、dubbo、zookeeper、docker的话，面试官还会问一下这些东西。比如redis可能会问你：为什么要用 redis、为什么要用 redis 而不用 map/guava 做缓存、redis 常见数据结构以及使用场景分析、 redis 设置过期时间、redis 内存淘汰机制、 redis 持久化机制、 缓存雪崩和缓存穿透问题、如何解决 Redis 的并发竞争 Key 问题、如何保证缓存与数据库双写时的数据一致性。</li><li>一些简单的 Linux 命令。</li><li>为什么要用 消息队列</li><li>关于 Java多线程，在面试的时候，问的比较多的就是①悲观锁和乐观锁②synchronized 和 ReenTrantLock 区别以及 volatile 和 synchronized 的区别，③可重入锁与非可重入锁的区别、④多线程是解决什么问题的、⑤线程池解决什么问题，为什么要用线程池 ⑥Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 ReenTrantLock 对比；⑦线程池使用时的注意事项、⑧AQS 原理以及 AQS 同步组件：Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock、⑨ReentranLock源码，设计原理，整体过程 等等问题。</li><li>关于 Java 虚拟机问的比较多的是：①Java内存区域、②虚拟机垃圾算法、③虚拟机垃圾收集器、④JVM内存管理、⑤JVM调优这些问题。 </li></ul><h3 id="面试后"><a href="#面试后" class="headerlink" title="面试后"></a>面试后</h3><p>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;秋招历程流水账总结&quot;&gt;&lt;a href=&quot;#秋招历程流水账总结&quot; class=&quot;headerlink&quot; title=&quot;秋招历程流水账总结&quot;&gt;&lt;/a&gt;秋招历程流水账总结&lt;/h1&gt;&lt;p&gt;笔主大四准毕业生，在秋招末流比较幸运地进入了一家自己非常喜欢一家公司——Though
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E7%BD%91%E6%98%932018%E6%A0%A1%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%981-3/"/>
    <id>http://yoursite.com/2019/01/17/网易2018校招编程题1-3/</id>
    <published>2019-01-17T14:36:16.986Z</published>
    <updated>2019-01-14T05:35:11.676Z</updated>
    
    <content type="html"><![CDATA[<p>下面三道编程题来自网易2018校招编程题，这三道应该来说是非常简单的编程题了，这些题目大家稍微有点编程和数学基础的话应该没什么问题。看答案之前一定要自己先想一下如果是自己做的话会怎么去做，然后再对照这我的答案看看，和你自己想的有什么区别？那一种方法更好？</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/7/1647557d5a1474d7?w=1024&amp;h=1024&amp;f=jpeg&amp;s=638271" alt="问题"></p><blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1></blockquote><h2 id="一-获得特定数量硬币问题"><a href="#一-获得特定数量硬币问题" class="headerlink" title="一 获得特定数量硬币问题"></a>一 获得特定数量硬币问题</h2><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。</p><p>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币</p><p>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币</p><p>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。 </p><p><strong>输入描述:</strong> 输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。</p><p><strong>输出描述:</strong> 输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符’1’和’2’。</p><p><strong>输入例子1:</strong> 10</p><p><strong>输出例子1:</strong> 122</p><h2 id="二-求“相反数”问题"><a href="#二-求“相反数”问题" class="headerlink" title="二 求“相反数”问题"></a>二 求“相反数”问题</h2><p>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1. </p><p><strong>输入描述:</strong> 输入包括一个整数n,(1 ≤ n ≤ 10^5)</p><p><strong>输出描述:</strong> 输出一个整数,表示n的相反数</p><p><strong>输入例子1:</strong> 1325</p><p><strong>输出例子1:</strong> 6556</p><h2 id="三-字符串碎片的平均长度"><a href="#三-字符串碎片的平均长度" class="headerlink" title="三 字符串碎片的平均长度"></a>三 字符串碎片的平均长度</h2><p>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。</p><p><strong>输入描述:</strong> 输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母(‘a’-‘z’)</p><p><strong>输出描述:</strong> 输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。</p><p><strong>如样例所示:</strong> s = “aaabbaaac”<br>所有碎片的平均长度 = (3 + 2 + 3 + 1) / 4 = 2.25</p><p><strong>输入例子1:</strong> aaabbaaac</p><p><strong>输出例子1:</strong> 2.25</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/7/16475582faddc9b2?w=1024&amp;h=1024&amp;f=jpeg&amp;s=531663" alt="答案"></p><blockquote><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1></blockquote><h2 id="一-获得特定数量硬币问题-1"><a href="#一-获得特定数量硬币问题-1" class="headerlink" title="一 获得特定数量硬币问题"></a>一 获得特定数量硬币问题</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>作为该试卷的第一题，这道题应该只要思路正确就很简单了。</p><p>解题关键：明确魔法机器1只能产生奇数，魔法机器2只能产生偶数即可。我们从后往前一步一步推回去即可。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>注意：由于用户的输入不确定性，一般是为了程序高可用性使需要将捕获用户输入异常然后友好提示用户输入类型错误并重新输入的。所以下面我给了两个版本，这两个版本都是正确的。这里只是给大家演示如何捕获输入类型异常，后面的题目中我给的代码没有异常处理的部分，参照下面两个示例代码，应该很容易添加。（PS：企业面试中没有明确就不用添加异常处理，当然你有的话也更好）</p><p><strong>不带输入异常处理判断的版本：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"><span class="comment">// 解题关键：明确魔法机器1只能产生奇数，魔法机器2只能产生偶数即可。我们从后往前一步一步推回去即可。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"请输入要获得的硬币数量："</span>);</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> coincount = scanner.nextInt();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (coincount &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 偶数的情况</span></span><br><span class="line"><span class="keyword">if</span> (coincount % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">coincount = (coincount - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">sb.append(<span class="string">"2"</span>);</span><br><span class="line"><span class="comment">// 奇数的情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">coincount = (coincount - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">sb.append(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出反转后的字符串</span></span><br><span class="line">System.out.println(sb.reverse());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带输入异常处理判断的版本（当输入的不是整数的时候会提示重新输入）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="comment">// 解题关键：明确魔法机器1只能产生奇数，魔法机器2只能产生偶数即可。我们从后往前一步一步推回去即可。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"请输入要获得的硬币数量："</span>);</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (flag) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> coincount = scanner.nextInt();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (coincount &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 偶数的情况</span></span><br><span class="line"><span class="keyword">if</span> (coincount % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">coincount = (coincount - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">sb.append(<span class="string">"2"</span>);</span><br><span class="line"><span class="comment">// 奇数的情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">coincount = (coincount - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">sb.append(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出反转后的字符串</span></span><br><span class="line">System.out.println(sb.reverse());</span><br><span class="line">flag=<span class="keyword">false</span>;<span class="comment">//程序结束</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InputMismatchException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"输入数据类型不匹配，请您重新输入:"</span>);</span><br><span class="line">scanner.nextLine();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-求“相反数”问题-1"><a href="#二-求“相反数”问题-1" class="headerlink" title="二 求“相反数”问题"></a>二 求“相反数”问题</h2><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>解决本道题有几种不同的方法，但是最快速的方法就是利用reverse()方法反转字符串然后再将字符串转换成int类型的整数，这个方法是快速解决本题关键。我们先来回顾一下下面两个知识点：</p><p><strong>1)String转int；</strong></p><p>在 Java 中要将 String 类型转化为 int 类型时,需要使用 Integer 类中的 parseInt() 方法或者 valueOf() 方法进行转换.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(str);</span><br></pre></td></tr></table></figure></p><p> 或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> a = Integer.valueOf(str).intValue()；</span><br></pre></td></tr></table></figure></p><p><strong>2)next()和nextLine()的区别</strong></p><p>在Java中输入字符串有两种方法，就是next()和nextLine().两者的区别就是：nextLine()的输入是碰到回车就终止输入，而next()方法是碰到空格，回车，Tab键都会被视为终止符。所以next()不会得到带空格的字符串，而nextLine()可以得到带空格的字符串。</p><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本题关键：①String转int；②next()和nextLine()的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入一个整数："</span>);</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s=scanner.next(); </span><br><span class="line"><span class="comment">//将字符串转换成数字</span></span><br><span class="line"><span class="keyword">int</span> number1=Integer.parseInt(s);</span><br><span class="line"><span class="comment">//将字符串倒序后转换成数字</span></span><br><span class="line"><span class="comment">//因为Integer.parseInt()的参数类型必须是字符串所以必须加上toString()</span></span><br><span class="line"><span class="keyword">int</span> number2=Integer.parseInt(<span class="keyword">new</span> StringBuilder(s).reverse().toString());</span><br><span class="line">System.out.println(number1+number2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-字符串碎片的平均长度-1"><a href="#三-字符串碎片的平均长度-1" class="headerlink" title="三 字符串碎片的平均长度"></a>三 字符串碎片的平均长度</h2><h3 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h3><p>这道题的意思也就是要求：(字符串的总长度)/(相同字母团构成的字符串的个数)。</p><p>这样就很简单了，就变成了字符串的字符之间的比较。如果需要比较字符串的字符的话，我们可以利用charAt(i)方法：取出特定位置的字符与后一个字符比较，或者利用toCharArray()方法将字符串转换成字符数组采用同样的方法做比较。</p><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p><strong>利用charAt(i)方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        <span class="comment">//个数至少为一个</span></span><br><span class="line">        <span class="keyword">float</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.length() / count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用toCharArray()方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        <span class="comment">//个数至少为一个</span></span><br><span class="line">        <span class="keyword">float</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> [] stringArr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringArr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringArr[i] != stringArr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.length() / count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面三道编程题来自网易2018校招编程题，这三道应该来说是非常简单的编程题了，这些题目大家稍微有点编程和数学基础的话应该没什么问题。看答案之前一定要自己先想一下如果是自己做的话会怎么去做，然后再对照这我的答案看看，和你自己想的有什么区别？那一种方法更好？&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/MySQL%20(2)/"/>
    <id>http://yoursite.com/2019/01/17/MySQL (2)/</id>
    <published>2019-01-17T14:35:32.501Z</published>
    <updated>2019-01-14T05:35:11.622Z</updated>
    
    <content type="html"><![CDATA[<p>Java面试通关手册（Java学习指南，欢迎Star，会一直完善下去，欢迎建议和指导）：<a href="https://github.com/Snailclimb/Java_Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java_Guide</a></p><blockquote><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2></blockquote><p><strong>《高性能MySQL : 第3版》</strong></p><blockquote><h2 id="文字教程推荐"><a href="#文字教程推荐" class="headerlink" title="文字教程推荐"></a>文字教程推荐</h2></blockquote><p><a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL 教程（菜鸟教程）</a></p><p><a href="https://www.yiibai.com/mysql/" target="_blank" rel="noopener">MySQL教程（易百教程）</a></p><blockquote><h2 id="视频教程推荐"><a href="#视频教程推荐" class="headerlink" title="视频教程推荐"></a>视频教程推荐</h2></blockquote><p><strong>基础入门：</strong> <a href="https://www.imooc.com/learn/122" target="_blank" rel="noopener">与MySQL的零距离接触-慕课网</a></p><p><strong>Mysql开发技巧：</strong> <a href="https://www.imooc.com/learn/398" target="_blank" rel="noopener">MySQL开发技巧（一）</a>　　<a href="https://www.imooc.com/learn/427" target="_blank" rel="noopener">MySQL开发技巧（二）</a>　　<a href="https://www.imooc.com/learn/449" target="_blank" rel="noopener">MySQL开发技巧（三）</a></p><p><strong>Mysql5.7新特性及相关优化技巧：</strong> <a href="https://www.imooc.com/learn/533" target="_blank" rel="noopener">MySQL5.7版本新特性</a>　　<a href="https://www.imooc.com/learn/194" target="_blank" rel="noopener">性能优化之MySQL优化</a></p><p><a href="https://www.imooc.com/learn/993" target="_blank" rel="noopener">MySQL集群（PXC）入门</a>　　<a href="https://www.imooc.com/learn/951" target="_blank" rel="noopener">MyCAT入门及应用</a></p><blockquote><h2 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h2></blockquote><ul><li><h3 id="①存储引擎"><a href="#①存储引擎" class="headerlink" title="①存储引擎"></a>①存储引擎</h3><p><a href="https://juejin.im/post/5b1685bef265da6e5c3c1c34" target="_blank" rel="noopener">MySQL常见的两种存储引擎：MyISAM与InnoDB的爱恨情仇</a></p></li><li><h3 id="②字符集及校对规则"><a href="#②字符集及校对规则" class="headerlink" title="②字符集及校对规则"></a>②字符集及校对规则</h3><p> 字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。Mysql中每一种字符集都会对应一系列的校对规则。</p><p> Mysql采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》</p><p> 详细内容可以参考：   <a href="https://www.cnblogs.com/geaozhang/p/6724393.html#mysqlyuzifuji" target="_blank" rel="noopener">MySQL字符集及校对规则的理解</a></p></li><li><h3 id="③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）"><a href="#③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）" class="headerlink" title="③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）"></a>③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）</h3><p>　　Mysql索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p>　　Mysql的BTree索引使用的是B数中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p><p>　　<strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p>　　<strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong> PS：整理自《Java工程师修炼之道》</p><p> 详细内容可以参考：</p><p> <a href="https://www.jianshu.com/p/1775b4ff123a" target="_blank" rel="noopener">干货：mysql索引的数据结构</a></p><p> <a href="https://blog.csdn.net/Jack__Frost/article/details/72571540" target="_blank" rel="noopener">MySQL优化系列（三）–索引的使用、原理和设计优化</a></p><p> <a href="https://juejin.im/post/5b55b842f265da0f9e589e79#comment" target="_blank" rel="noopener">数据库两大神器【索引和锁】</a></p></li><li><h3 id="④查询缓存的使用"><a href="#④查询缓存的使用" class="headerlink" title="④查询缓存的使用"></a>④查询缓存的使用</h3><p> my.cnf加入以下配置，重启Mysql开启查询缓存</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=1</span><br><span class="line">query_cache_size=600000</span><br></pre></td></tr></table></figure></li></ul><p>   Mysql执行以下命令也可以开启查询缓存</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global  query_cache_type=1;</span><br><span class="line">set global  query_cache_size=600000;</span><br></pre></td></tr></table></figure><p>   如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、Mysql库中的系统表，其查询结果也不会被缓存。</p><p>   缓存建立之后，Mysql的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p><p>   <strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，<strong>还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：</strong><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sql_no_cache count(*) from usr;</span><br></pre></td></tr></table></figure></p><ul><li><h3 id="⑤事务机制"><a href="#⑤事务机制" class="headerlink" title="⑤事务机制"></a>⑤事务机制</h3><p> <strong>关系性数据库需要遵循ACID规则，具体内容如下：</strong></p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637b08b98619455?w=312&amp;h=305&amp;f=png&amp;s=22430" alt="事务的特性"></p><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据库从一个一致性状态转换到另一个一致性状态。</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><p><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。</p><p><strong>为了达到上述事务特性，数据库定义了几种不同的事务隔离级别：</strong></p></li></ol><ul><li><strong>READ_UNCOMMITTED（未提交读）:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong>READ_COMMITTED（提交读）:</strong>     允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong>REPEATABLE_READ（可重复读）:</strong>     对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><p><strong>SERIALIZABLE（串行）:</strong>     最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p><p>这里需要注意的是：<strong>Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</strong></p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVCC（多版本并发控制），通过行的创建时间和行的过期时间来支持并发一致性读和回滚等特性。</p><p> 详细内容可以参考：   <a href="https://blog.csdn.net/qq_34337272/article/details/80394121" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a></p></li><li><h3 id="⑥锁机制与InnoDB锁算法"><a href="#⑥锁机制与InnoDB锁算法" class="headerlink" title="⑥锁机制与InnoDB锁算法"></a>⑥锁机制与InnoDB锁算法</h3><p> <strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p><ul><li>MyISAM采用表级锁(table-level locking)。</li><li><p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p><p><strong>表级锁和行级锁对比：</strong></p><ul><li><strong>表级锁：</strong> Mysql中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li><li><strong>行级锁：</strong> Mysql中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 </li></ul><p>详细内容可以参考：<br><a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">Mysql锁机制简单了解一下</a></p></li></ul><p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p><ul><li>Record lock：单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li><p>Next-key lock：record+gap 锁定一个范围，包含记录本身</p><p><strong>相关知识点：</strong></p><ol><li>innodb对于行的查询使用next-key lock</li><li>Next-locking keying为了解决Phantom Problem幻读问题</li><li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol></li></ul></li><li><h3 id="⑦大表优化"><a href="#⑦大表优化" class="headerlink" title="⑦大表优化"></a>⑦大表优化</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li><li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li><li><p><strong>垂直分区：</strong> </p><p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。<br><img src="https://user-gold-cdn.xitu.io/2018/6/16/164084354ba2e0fd?w=950&amp;h=279&amp;f=jpeg&amp;s=26015" alt=""></p><p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p></li><li><p><strong>水平分区：</strong> </p></li></ol></li></ul><pre><code>**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。** 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。![数据库水平拆分](https://user-gold-cdn.xitu.io/2018/6/16/164084b7e9e423e3?w=690&amp;h=271&amp;f=jpeg&amp;s=23119)水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决**  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。**下面补充一下数据库分片的两种常见方案：**- **客户端代理：**  **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。</code></pre><p>  详细内容可以参考：<br>  <a href="https://segmentfault.com/a/1190000006158186" target="_blank" rel="noopener">MySQL大表优化方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java面试通关手册（Java学习指南，欢迎Star，会一直完善下去，欢迎建议和指导）：&lt;a href=&quot;https://github.com/Snailclimb/Java_Guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/MySQL%20Index/"/>
    <id>http://yoursite.com/2019/01/17/MySQL Index/</id>
    <published>2019-01-17T14:35:29.751Z</published>
    <updated>2019-01-14T05:35:11.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图-索引篇"><a href="#思维导图-索引篇" class="headerlink" title="思维导图-索引篇"></a>思维导图-索引篇</h1><blockquote><p>系列思维导图源文件（数据库+架构）以及思维导图制作软件—XMind8 破解安装，公众号后台回复：<strong>“思维导图”</strong> 免费领取！（下面的图片不是很清楚，原图非常清晰，另外提供给大家源文件也是为了大家根据自己需要进行修改）</p></blockquote><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/70973487.jpg" alt="【思维导图-索引篇】"></p><blockquote><p><strong>下面是我补充的一些内容</strong></p></blockquote><h1 id="为什么索引能提高查询速度"><a href="#为什么索引能提高查询速度" class="headerlink" title="为什么索引能提高查询速度"></a>为什么索引能提高查询速度</h1><blockquote><p>以下内容整理自：<br> 地址： <a href="https://juejin.im/post/5b55b842f265da0f9e589e79" target="_blank" rel="noopener">https://juejin.im/post/5b55b842f265da0f9e589e79</a><br> 作者 ：Java3y</p></blockquote><h3 id="先从-MySQL-的基本存储结构说起"><a href="#先从-MySQL-的基本存储结构说起" class="headerlink" title="先从 MySQL 的基本存储结构说起"></a>先从 MySQL 的基本存储结构说起</h3><p>MySQL的基本存储结构是页(记录都存在页里边)：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/28559421.jpg" alt="MySQL的基本存储结构是页"></p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/82053134.jpg" alt=""></p><ul><li><strong>各个数据页可以组成一个双向链表</strong></li><li><strong>每个数据页中的记录又可以组成一个单向链表</strong><ul><li>每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li>以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。</li></ul></li></ul><p>所以说，如果我们写select * from user where indexname = ‘xxx’这样没有进行任何优化的sql语句，默认会这样做：</p><ol><li><strong>定位到记录所在的页:需要遍历双向链表，找到所在的页</strong></li><li><strong>从所在的页内中查找相应的记录:由于不是根据主键查询，只能遍历所在页的单链表了</strong></li></ol><p>很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。</p><h3 id="使用索引之后"><a href="#使用索引之后" class="headerlink" title="使用索引之后"></a>使用索引之后</h3><p>索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/5373082.jpg" alt=""></p><p>要找到id为8的记录简要步骤：</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/89338047.jpg" alt=""></p><p>很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 <strong>“目录”</strong> 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）</p><p>其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。</p><h1 id="关于索引其他重要的内容补充"><a href="#关于索引其他重要的内容补充" class="headerlink" title="关于索引其他重要的内容补充"></a>关于索引其他重要的内容补充</h1><blockquote><p>以下内容整理自：《Java工程师修炼之道》</p></blockquote><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)o而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name=xx and city=xx ; ／／可以命中索引</span><br><span class="line">select * from user where name=xx ; // 可以命中索引</span><br><span class="line">select * from user where city=xx; // 无法命中索引            </span><br><span class="line">```                                                          </span><br><span class="line">这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.</span><br><span class="line"></span><br><span class="line">由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDERBY子句也遵循此规则。</span><br><span class="line"></span><br><span class="line">### 注意避免冗余索引</span><br><span class="line"></span><br><span class="line">冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</span><br><span class="line"></span><br><span class="line">MySQLS.7 版本后，可以通过查询 sys 库的 `schemal_r dundant_indexes` 表来查看冗余索引             </span><br><span class="line"></span><br><span class="line">### Mysql如何为表字段添加索引？？？</span><br><span class="line"></span><br><span class="line">1.添加PRIMARY KEY（主键索引）</span><br></pre></td></tr></table></figure><p>ALTER TABLE <code>table_name</code> ADD PRIMARY KEY ( <code>column</code> )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.添加UNIQUE(唯一索引)</span><br></pre></td></tr></table></figure></p><p>ALTER TABLE <code>table_name</code> ADD UNIQUE ( <code>column</code> )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">3.添加INDEX(普通索引)</span><br></pre></td></tr></table></figure></p><p>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column</code> )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">4.添加FULLTEXT(全文索引)</span><br></pre></td></tr></table></figure></p><p>ALTER TABLE <code>table_name</code> ADD FULLTEXT ( <code>column</code>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">5.添加多列索引</span><br></pre></td></tr></table></figure></p><p>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code> )<br><code>`</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《Java工程师修炼之道》</li><li>《MySQL高性能书籍_第3版》</li><li><a href="https://juejin.im/post/5b55b842f265da0f9e589e79" target="_blank" rel="noopener">https://juejin.im/post/5b55b842f265da0f9e589e79</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思维导图-索引篇&quot;&gt;&lt;a href=&quot;#思维导图-索引篇&quot; class=&quot;headerlink&quot; title=&quot;思维导图-索引篇&quot;&gt;&lt;/a&gt;思维导图-索引篇&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系列思维导图源文件（数据库+架构）以及思维导图制作软件—XMind
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E7%AE%97%E6%B3%95%20(2)/"/>
    <id>http://yoursite.com/2019/01/17/算法 (2)/</id>
    <published>2019-01-17T14:35:17.562Z</published>
    <updated>2019-01-14T05:35:11.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">LeetCode（中国）官网</a></p><p><a href="https://leetcode-cn.com/articles/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8-leetcode/" target="_blank" rel="noopener">如何高效地使用 LeetCode</a></p><h2 id="牛客网："><a href="#牛客网：" class="headerlink" title="牛客网："></a>牛客网：</h2><p><a href="https://www.nowcoder.com" target="_blank" rel="noopener">牛客网首页</a></p><blockquote><h3 id="剑指offer编程题"><a href="#剑指offer编程题" class="headerlink" title="剑指offer编程题"></a><strong><a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">剑指offer编程题</a></strong></h3></blockquote><p><strong>分类解析：</strong></p><ul><li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（1）斐波那契数列问题和跳台阶问题.md" target="_blank" rel="noopener">（1）斐波那契数列问题和跳台阶问题</a></li><li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（2）二维数组查找和替换空格问题.md" target="_blank" rel="noopener">（2）二维数组查找和替换空格问题</a></li><li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（3）数值的整数次方和调整数组元素顺序.md" target="_blank" rel="noopener">（3）数值的整数次方和调整数组元素顺序</a></li><li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（4）链表相关编程题.md" target="_blank" rel="noopener">（4）链表相关编程题</a></li><li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/剑指offer/（5）栈变队列和栈的压入、弹出序列.md" target="_blank" rel="noopener">（5）栈变队列和栈的压入、弹出序列</a></li></ul><blockquote><h3 id="2017校招真题"><a href="#2017校招真题" class="headerlink" title="2017校招真题"></a><a href="https://www.nowcoder.com/ta/2017test" target="_blank" rel="noopener">2017校招真题</a></h3></blockquote><blockquote><h3 id="华为机试题"><a href="#华为机试题" class="headerlink" title="华为机试题"></a><a href="https://www.nowcoder.com/ta/huawei" target="_blank" rel="noopener">华为机试题</a></h3></blockquote><h2 id="公司真题"><a href="#公司真题" class="headerlink" title="公司真题"></a>公司真题</h2><blockquote><p><a href="https://www.nowcoder.com/test/6910869/summary" target="_blank" rel="noopener"> 网易2018校园招聘编程题真题集合</a></p></blockquote><p><strong>解析：</strong></p><ul><li><a href="https://github.com/Snailclimb/Java-Guide/tree/master/数据结构与算法/算法题解析/公司真题/网易2018校招编程题1-3.md" target="_blank" rel="noopener"> 网易2018校招编程题1-3</a></li></ul><blockquote><p><a href="https://www.nowcoder.com/test/6291726/summary" target="_blank" rel="noopener"> 网易2018校招内推编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/5986669/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第五场)编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/5507925/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第四场)编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/5217106/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第三场)编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/4546329/summary" target="_blank" rel="noopener">2017年校招全国统一模拟笔试(第二场)编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/4236887/summary" target="_blank" rel="noopener"> 2017年校招全国统一模拟笔试(第一场)编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/4998655/summary" target="_blank" rel="noopener">百度2017春招笔试真题编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/4575457/summary" target="_blank" rel="noopener">网易2017春招笔试真题编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/2811407/summary" target="_blank" rel="noopener">网易2017秋招编程题集合</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/2385858/summary" target="_blank" rel="noopener">网易有道2017内推编程题</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/3701760/summary" target="_blank" rel="noopener"> 滴滴出行2017秋招笔试真题-编程题汇总</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/1725829/summary" target="_blank" rel="noopener">腾讯2017暑期实习生编程题</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/1649301/summary" target="_blank" rel="noopener">今日头条2017客户端工程师实习生笔试题</a></p></blockquote><blockquote><p><a href="https://www.nowcoder.com/test/1649268/summary" target="_blank" rel="noopener">今日头条2017后端工程师实习生笔试题</a></p></blockquote><h2 id="排序算法："><a href="#排序算法：" class="headerlink" title="排序算法："></a>排序算法：</h2><p><a href="http://www.cnblogs.com/chengxiao/p/6103002.html" target="_blank" rel="noopener">图解排序算法(一)之3种简单排序(选择，冒泡，直接插入)</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p><p><a href="http://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></p><p><a href="http://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p><p><a href="http://www.cnblogs.com/chengxiao/p/6262208.html" target="_blank" rel="noopener">图解排序算法(五)之快速排序——三数取中法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LeetCode&quot;&gt;&lt;a href=&quot;#LeetCode&quot; class=&quot;headerlink&quot; title=&quot;LeetCode&quot;&gt;&lt;/a&gt;LeetCode&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/&quot; target=&quot;_bl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/01/17/%E6%90%9E%E5%AE%9ABAT%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%87%A0%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%90%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/17/搞定BAT面试——几道常见的子符串算法题/</id>
    <published>2019-01-17T14:35:15.151Z</published>
    <updated>2019-01-14T05:35:11.670Z</updated>
    
    <content type="html"><![CDATA[<!-- MarkdownTOC --><ul><li><a href="#说明">说明</a></li><li><a href="#1-kmp-算法">1. KMP 算法</a></li><li><a href="#2-替换空格">2. 替换空格</a></li><li><a href="#3-最长公共前缀">3. 最长公共前缀</a></li><li><a href="#4-回文串">4. 回文串</a><ul><li><a href="#41-最长回文串">4.1. 最长回文串</a></li><li><a href="#42-验证回文串">4.2. 验证回文串</a></li><li><a href="#43-最长回文子串">4.3. 最长回文子串</a></li><li><a href="#44-最长回文子序列">4.4. 最长回文子序列</a></li></ul></li><li><a href="#5-括号匹配深度">5. 括号匹配深度</a></li><li><a href="#6-把字符串转换成整数">6. 把字符串转换成整数</a></li></ul><!-- /MarkdownTOC --><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>本文作者：wwwxmu</li><li>原文地址:<a href="https://www.weiweiblog.cn/13string/" target="_blank" rel="noopener">https://www.weiweiblog.cn/13string/</a></li><li>作者的博客站点：<a href="https://www.weiweiblog.cn/" target="_blank" rel="noopener">https://www.weiweiblog.cn/</a> （推荐哦！）</li></ul><p>考虑到篇幅问题，我会分两次更新这个内容。本篇文章只是原文的一部分，我在原文的基础上增加了部分内容以及修改了部分代码和注释。另外，我增加了爱奇艺 2018 秋招 Java：<code>求给定合法括号序列的深度</code> 这道题。所有代码均编译成功，并带有注释，欢迎各位享用！</p><h2 id="1-KMP-算法"><a href="#1-KMP-算法" class="headerlink" title="1. KMP 算法"></a>1. KMP 算法</h2><p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p><p>具体算法细节请参考：</p><ul><li><strong>字符串匹配的KMP算法:</strong> <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></li><li><strong>从头到尾彻底理解KMP:</strong> <a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></li><li><strong>如何更好的理解和掌握 KMP 算法?:</strong> <a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">https://www.zhihu.com/question/21923021</a></li><li><strong>KMP 算法详细解析:</strong>  <a href="https://blog.sengxian.com/algorithms/kmp" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/kmp</a></li><li><strong>图解 KMP 算法:</strong> <a href="http://blog.jobbole.com/76611/" target="_blank" rel="noopener">http://blog.jobbole.com/76611/</a></li><li><strong>汪都能听懂的KMP字符串匹配算法【双语字幕】:</strong> <a href="https://www.bilibili.com/video/av3246487/?from=search&amp;seid=17173603269940723925" target="_blank" rel="noopener">https://www.bilibili.com/video/av3246487/?from=search&amp;seid=17173603269940723925</a></li><li><strong>KMP字符串匹配算法1:</strong> <a href="https://www.bilibili.com/video/av11866460?from=search&amp;seid=12730654434238709250" target="_blank" rel="noopener">https://www.bilibili.com/video/av11866460?from=search&amp;seid=12730654434238709250</a></li></ul><p><strong>除此之外，再来了解一下BM算法！</strong></p><blockquote><p>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。<br>《字符串匹配的KMP算法》:<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p></blockquote><h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h2><blockquote><p>剑指offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>这里我提供了两种方法：①常规方法；②利用 API 解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/replacespace/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(" "</span></span><br><span class="line"><span class="comment">   * )遍历字符串并判断元素是否为空格。是则替换为"%20",否则不替换</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="comment">// System.out.println("length=" + length);</span></span><br><span class="line">    StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> b = str.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">" "</span>)) &#123;</span><br><span class="line">        result.append(<span class="string">"%20"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.append(b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第二种方法：利用API替换掉所用空格，一行代码解决问题</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace2</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str.toString().replaceAll(<span class="string">"\\s"</span>, <span class="string">"%20"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h2><blockquote><p>Leetcode:  编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p></blockquote><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p>思路很简单！先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-common-prefix/description/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = strs.length;</span><br><span class="line">    <span class="comment">// 用于保存结果</span></span><br><span class="line">    StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="comment">// 注意：=是赋值，==是判断</span></span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给字符串数组的元素按照升序排序(包含数字的话，数字会排在前面)</span></span><br><span class="line">    Arrays.sort(strs);</span><br><span class="line">    <span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line">    <span class="keyword">int</span> n = strs[len - <span class="number">1</span>].length();</span><br><span class="line">    <span class="keyword">int</span> num = Math.min(m, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">        res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">     <span class="comment">//测试</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] strs = &#123; <span class="string">"customer"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span> &#125;;</span><br><span class="line">    System.out.println(Main.replaceSpace(strs));<span class="comment">//c</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-回文串"><a href="#4-回文串" class="headerlink" title="4. 回文串"></a>4. 回文串</h2><h3 id="4-1-最长回文串"><a href="#4-1-最长回文串" class="headerlink" title="4.1. 最长回文串"></a>4.1. 最长回文串</h3><blockquote><p>LeetCode:  给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如<code>&quot;Aa&quot;</code>不能当做一个回文字符串。注<br>意:假设字符串的长度不会超过 1010。</p></blockquote><blockquote><p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科  地址：<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin</a></p></blockquote><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure><p>我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：</p><ul><li>字符出现次数为双数的组合</li><li>字符出现次数为双数的组合+一个只出现一次的字符</li></ul><p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在hashset中，如果不在就加进去，如果在就让count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindrome/description/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用于存放字符</span></span><br><span class="line">    HashSet&lt;Character&gt; hashset = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hashset.contains(chars[i])) &#123;<span class="comment">// 如果hashset没有该字符就保存进去</span></span><br><span class="line">        hashset.add(chars[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果有,就让count++（说明找到了一个成对的字符），然后把该字符移除</span></span><br><span class="line">        hashset.remove(chars[i]);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashset.isEmpty() ? count * <span class="number">2</span> : count * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-验证回文串"><a href="#4-2-验证回文串" class="headerlink" title="4.2. 验证回文串"></a>4.2. 验证回文串</h3><blockquote><p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p></blockquote><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/valid-palindrome/description/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="comment">// 从头和尾开始向中间遍历</span></span><br><span class="line">      <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(l))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        l++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(r))) &#123;<span class="comment">// 字符不是字母和数字的情况</span></span><br><span class="line">        r--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断二者是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-最长回文子串"><a href="#4-3-最长回文子串" class="headerlink" title="4.3. 最长回文子串"></a>4.3. 最长回文子串</h3><blockquote><p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p></blockquote><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。给大家大致花了个草图，不要嫌弃！</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bc32f6f1833ff?w=723&amp;h=371&amp;f=png&amp;s=9305" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/longest-palindromic-substring/description/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index, len;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      PalindromeHelper(s, i, i);</span><br><span class="line">      PalindromeHelper(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(index, index + len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PalindromeHelper</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">      l--;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; r - l - <span class="number">1</span>) &#123;</span><br><span class="line">      index = l + <span class="number">1</span>;</span><br><span class="line">      len = r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-最长回文子序列"><a href="#4-4-最长回文子序列" class="headerlink" title="4.4. 最长回文子序列"></a>4.4. 最长回文子序列</h3><blockquote><p>LeetCode: 最长回文子序列<br>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。<br><strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，”bbbb”可以是字符串”bbbab”的子序列但不是子串。</strong></p></blockquote><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">输出:</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>一个可能的最长回文子序列为 “bb”。</p><p><strong>动态规划：</strong>  dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-括号匹配深度"><a href="#5-括号匹配深度" class="headerlink" title="5. 括号匹配深度"></a>5. 括号匹配深度</h2><blockquote><p>爱奇艺 2018 秋招 Java：<br>一个合法的括号匹配序列有以下定义:</p><ol><li>空串””是一个合法的括号匹配序列</li><li>如果”X”和”Y”都是合法的括号匹配序列,”XY”也是一个合法的括号匹配序列</li><li>如果”X”是一个合法的括号匹配序列,那么”(X)”也是一个合法的括号匹配序列</li><li>每个合法的括号序列都可以由以上规则生成。</li></ol></blockquote><blockquote><p>例如: “”,”()”,”()()”,”((()))”都是合法的括号序列<br>对于一个合法的括号序列我们又有以下定义它的深度:</p><ol><li>空串””的深度是0</li><li>如果字符串”X”的深度是x,字符串”Y”的深度是y,那么字符串”XY”的深度为max(x,y)   </li><li>如果”X”的深度是x,那么字符串”(X)”的深度是x+1</li></ol></blockquote><blockquote><p>例如: “()()()”的深度是1,”((()))”的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入描述:</span><br><span class="line">输入包括一个合法的括号序列s,s长度length(2 ≤ length ≤ 50),序列中只包含&apos;(&apos;和&apos;)&apos;。</span><br><span class="line"></span><br><span class="line">输出描述:</span><br><span class="line">输出一个正整数,即这个序列的深度。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">(())</span><br><span class="line">输出:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>思路草图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bc6fca94ef278?w=792&amp;h=324&amp;f=png&amp;s=15868" alt=""></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/test/8246651/summary</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月6日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO 求给定合法括号序列的深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String s = sc.nextLine();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, max = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        cnt--;</span><br><span class="line">      max = Math.max(max, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    sc.close();</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-把字符串转换成整数"><a href="#6-把字符串转换成整数" class="headerlink" title="6. 把字符串转换成整数"></a>6. 把字符串转换成整数</h2><blockquote><p>剑指offer:  将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://www.weiweiblog.cn/strtoint/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="comment">// 判断是否存在符号位</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chars[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">      flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> start = flag &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">// 保存结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; chars.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Character.isDigit(chars[i])) &#123;<span class="comment">// 调用Character.isDigit(char)方法判断是否是数字，是返回True，否则False</span></span><br><span class="line">        <span class="keyword">int</span> temp = chars[i] - <span class="string">'0'</span>;</span><br><span class="line">        res = res * <span class="number">10</span> + temp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag == <span class="number">1</span> ? res : -res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    String s = <span class="string">"-12312312"</span>;</span><br><span class="line">    System.out.println(<span class="string">"使用库函数转换："</span> + Integer.valueOf(s));</span><br><span class="line">    <span class="keyword">int</span> res = Main.StrToInt(s);</span><br><span class="line">    System.out.println(<span class="string">"使用自己写的方法转换："</span> + res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- MarkdownTOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#说明&quot;&gt;说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1-kmp-算法&quot;&gt;1. KMP 算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-替换空格&quot;&gt;2. 替换空格&lt;/a&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
</feed>
